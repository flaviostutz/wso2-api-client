/* eslint-disable @typescript-eslint/naming-convention */
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/apis': {
    /**
     * This operation provides you a list of available APIs qualifying under a given search condition.
     *
     * Each retrieved API is represented with a minimal amount of attributes. If you want to get complete details of an API, you need to use **Get details of an API** operation.
     *
     * This operation supports retrieving APIs of other tenants. The required tenant domain need to be specified as a header `X-WSO2-Tenant`. If not specified super tenant's APIs will be retrieved. If you used an Authorization header, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * By default, this operation retrieves Published APIs and Prototyped APIs. In order to retrieve only Prototyped APIs, you need to use **query** parameter and specify **status:PROTOTYPED**. To retrieve Published APIs, use **query** parameter and specify **status:PUBLISHED**.
     * * This operation does not require an Authorization header by default. But if it is provided, it will be validated and checked for permissions of the user, hence you may be able to see APIs which are restricted for special permissions/roles.
     */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
          /**
           * **Search condition**.
           *
           * You can search in attributes by using an **"<attribute>:"** modifier.
           *
           * Eg.
           * "provider:wso2" will match an API if the provider of the API is exactly "wso2".
           *
           * Additionally you can use wildcards.
           *
           * Eg.
           * "provider:wso2*" will match an API if the provider of the API starts with "wso2".
           *
           * Supported attribute modifiers are [**version, context, status,
           * description, subcontext, doc, provider, tag**]
           *
           * If no advanced attribute modifier has been specified, search will match the
           * given query string against API Name.
           */
          query?: string;
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * List of qualifying APIs is returned.
         */
        200: {
          schema: definitions['APIList'];
        };
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}': {
    /**
     * Using this operation, you can retrieve complete details of a single API. You need to provide the Id of the API to retrive it.
     *
     * `X-WSO2-Tenant` header can be used to retrieve an API of a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But if it is provided, it will be validated and checked for permissions of the user, hence you may be able to see APIs which are restricted for special permissions/roles. \n
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Requested API is returned
         */
        200: {
          headers: {};
          schema: definitions['API'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/swagger': {
    /**
     * You can use this operation to retrieve the swagger definition of an API.
     *
     *  `X-WSO2-Tenant` header can be used to retrieve the swagger definition an API of a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But in order to see a restricted API's swagger definition, you need to provide Authorization header.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        query: {
          /** Name of the API microgateway labels */
          labelName?: parameters['labelName'];
          /** Name of the API gateway environment. */
          environmentName?: parameters['environmentName'];
          /** Name of the container managed cluster name. */
          clusterName?: parameters['clusterName'];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * Requested swagger document of the API is returned
         */
        200: {
          headers: {};
          schema: string;
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/graphql-schema': {
    /**
     * You can use this operation to retrieve the swagger definition of an API.
     *
     *  `X-WSO2-Tenant` header can be used to retrieve the swagger definition an API of a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But in order to see a restricted API's swagger definition, you need to provide Authorization header.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * Requested swagger document of the API is returned
         */
        200: unknown;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/sdks/{language}': {
    /** This operation can be used to generate SDKs (System Development Kits), for the APIs available in the API Developer Portal, for a requested development language. */
    get: {
      parameters: {
        path: {
          /** ID of the specific API for which the SDK is required. */
          apiId: string;
          /** Programming language of the SDK that is required. */
          language: string;
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * SDK generated successfully.
         */
        200: {
          schema: string;
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        500: responses['InternalServerError'];
      };
    };
  };
  '/apis/{apiId}/wsdl': {
    /** This operation can be used to retrieve the swagger definition of an API. */
    get: operations['getWSDLOfAPI'];
  };
  '/apis/{apiId}/documents': {
    /**
     * This operation can be used to retrive a list of documents belonging to an API by providing the id of the API.
     *
     * `X-WSO2-Tenant` header can be used to retrive documents of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But in order to see a restricted API's documents, you need to provide Authorization header.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Document list is returned.
         */
        200: {
          headers: {};
          schema: definitions['DocumentList'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/documents/{documentId}': {
    /**
     * This operation can be used to retrieve a particular document's metadata associated with an API.
     *
     * `X-WSO2-Tenant` header can be used to retrive a document of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But in order to see a restricted API's document, you need to provide Authorization header.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
          /** Document Identifier */
          documentId: parameters['documentId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Document returned.
         */
        200: {
          headers: {};
          schema: definitions['Document'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/documents/{documentId}/content': {
    /**
     * This operation can be used to retrive the content of an API's document.
     *
     * The document can be of 3 types. In each cases responses are different.
     *
     * 1. **Inline type**:
     *    The content of the document will be retrieved in `text/plain` content type
     * 2. **FILE type**:
     *    The file will be downloaded with the related content type (eg. `application/pdf`)
     * 3. **URL type**:
     *     The client will recieve the URL of the document as the Location header with the response with - `303 See Other`
     *
     * `X-WSO2-Tenant` header can be used to retrive the content of a document of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But in order to see a restricted API's document content, you need to provide Authorization header.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
          /** Document Identifier */
          documentId: parameters['documentId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * File or inline content returned.
         */
        200: unknown;
        /**
         * See Other.
         * Source can be retrived from the URL specified at the Location header.
         */
        303: never;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/thumbnail': {
    /**
     * This operation can be used to download a thumbnail image of an API.
     *
     * `X-WSO2-Tenant` header can be used to retrive a thumbnail of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But in order to see a restricted API's thumbnail, you need to provide Authorization header.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Thumbnail image returned
         */
        200: unknown;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/ratings': {
    /**
     * This operation can be used to retrieve the list of ratings of an API.
     *
     * `X-WSO2-Tenant` header can be used to retrieve ratings of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * Rating list returned.
         */
        200: {
          schema: definitions['RatingList'];
        };
        406: responses['NotAcceptable'];
      };
    };
  };
  '/apis/{apiId}/user-rating': {
    /**
     * This operation can be used to get the user rating of an API.
     *
     * `X-WSO2-Tenant` header can be used to retrieve the logged in user rating of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Rating returned.
         */
        200: {
          headers: {};
          schema: definitions['Rating'];
        };
        /**
         * Not Modified.
         * Empty body because the client already has the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
    /**
     * This operation can be used to add or update an API rating.
     *
     * `X-WSO2-Tenant` header can be used to add or update the logged in user rating of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     */
    put: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
        body: {
          /** Rating object that should to be added */
          body: definitions['Rating'];
        };
      };
      responses: {
        /**
         * OK.
         * Successful response with the newly created or updated object as entity in the body.
         */
        200: {
          headers: {};
          schema: definitions['Rating'];
        };
        400: responses['BadRequest'];
        415: responses['UnsupportedMediaType'];
      };
    };
    /**
     * This operation can be used to delete logged in user API rating.
     *
     * `X-WSO2-Tenant` header can be used to delete the logged in user rating of an API that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     */
    delete: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Resource successfully deleted.
         */
        200: unknown;
      };
    };
  };
  '/apis/{apiId}/comments': {
    /** Get a list of Comments that are already added to APIs */
    get: operations['getAllCommentsOfAPI'];
    post: operations['addCommentToAPI'];
  };
  '/apis/{apiId}/comments/{commentId}': {
    /** Get the individual comment given by a username for a certain API. */
    get: operations['getCommentOfAPI'];
    /** Remove a Comment */
    delete: operations['deleteComment'];
  };
  '/apis/{apiId}/subscription-policies': {
    /**
     * This operation can be used to retrieve details of the subscription throttling policy of an API by specifying the API Id.
     *
     * `X-WSO2-Tenant` header can be used to retrive API subscription throttling policies that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Throttling Policy returned
         */
        200: {
          headers: {};
          schema: definitions['ThrottlingPolicy'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/applications': {
    /** This operation can be used to retrieve list of applications that is belonged to the user associated with the provided access token. */
    get: {
      parameters: {
        query: {
          /** Application Group Id */
          groupId?: parameters['groupId'];
          /**
           * **Search condition**.
           *
           * You can search for an application by specifying the name as "query" attribute.
           *
           * Eg.
           * "app1" will match an application if the name is exactly "app1".
           *
           * Currently this does not support wildcards. Given name must exactly match the application name.
           */
          query?: string;
          sortBy?: 'name' | 'throttlingPolicy' | 'status';
          sortOrder?: 'asc' | 'desc';
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Application list returned.
         */
        200: {
          headers: {};
          schema: definitions['ApplicationList'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        400: responses['BadRequest'];
        406: responses['NotAcceptable'];
      };
    };
    /** This operation can be used to create a new application specifying the details of the application in the payload. */
    post: {
      parameters: {
        body: {
          /** Application object that is to be created. */
          body: definitions['Application'];
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created object as entity in the body.
         * Location header contains URL of newly created entity.
         */
        201: {
          headers: {};
          schema: definitions['Application'];
        };
        /**
         * Accepted.
         * The request has been accepted.
         */
        202: {
          headers: {};
          schema: definitions['WorkflowResponse'];
        };
        400: responses['BadRequest'];
        409: responses['Conflict'];
        415: responses['UnsupportedMediaType'];
      };
    };
  };
  '/applications/{applicationId}': {
    /** This operation can be used to retrieve details of an individual application specifying the application id in the URI. */
    get: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Application returned.
         */
        200: {
          headers: {};
          schema: definitions['Application'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
    /** This operation can be used to update an application. Upon succesfull you will retrieve the updated application as the response. */
    put: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
        };
        body: {
          /** Application object that needs to be updated */
          body: definitions['Application'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Application updated.
         */
        200: {
          headers: {};
          schema: definitions['Application'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
    /** This operation can be used to remove an application specifying its id. */
    delete: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Resource successfully deleted.
         */
        200: unknown;
        /**
         * Accepted.
         * The request has been accepted.
         */
        202: {
          headers: {};
          schema: definitions['WorkflowResponse'];
        };
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/generate-keys': {
    /** Generate keys (Consumer key/secret) for application */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
        };
        body: {
          /** Application key generation request object */
          body: definitions['ApplicationKeyGenerateRequest'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys are generated.
         */
        200: {
          schema: definitions['ApplicationKey'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/map-keys': {
    /** Map keys (Consumer key/secret) to an application */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
        };
        body: {
          /** Application key mapping request object */
          body: definitions['ApplicationKeyMappingRequest'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys are mapped.
         */
        200: {
          schema: definitions['ApplicationKey'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/keys': {
    /** Retrieve keys (Consumer key/secret) of application */
    get: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys are returned.
         */
        200: {
          schema: definitions['ApplicationKeyList'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/keys/{keyType}': {
    /** This operation can be used to retrieve key details of an individual application specifying the key type in the URI. */
    get: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox). */
          keyType: parameters['keyType'];
        };
        query: {
          /** Application Group Id */
          groupId?: parameters['groupId'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys of given type are returned.
         */
        200: {
          schema: definitions['ApplicationKey'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
    /** This operation can be used to update grant types and callback url of an application. (Consumer Key and Consumer Secret are ignored) Upon succesfull you will retrieve the updated key details as the response. */
    put: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox). */
          keyType: parameters['keyType'];
        };
        body: {
          /** Grant types/Callback URL update request object */
          body: definitions['ApplicationKey'];
        };
      };
      responses: {
        /**
         * Ok.
         * Grant types or/and callback url is/are updated.
         */
        200: {
          schema: definitions['ApplicationKey'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/keys/{keyType}/regenerate-secret': {
    /** This operation can be used to re generate consumer secret for an application for the give key type */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox). */
          keyType: parameters['keyType'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys are re generated.
         */
        200: {
          headers: {};
          schema: definitions['ApplicationKeyReGenerateResponse'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/keys/{keyType}/clean-up': {
    /** Clean up keys after failed key generation of an application */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox). */
          keyType: parameters['keyType'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Clean up is performed
         */
        200: unknown;
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/keys/{keyType}/generate-token': {
    /** Generate an access token for application by client_credentials grant type */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox). */
          keyType: parameters['keyType'];
        };
        body: {
          /** Application token generation request object */
          body: definitions['ApplicationTokenGenerateRequest'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Token is generated.
         */
        200: {
          schema: definitions['ApplicationToken'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/oauth-keys': {
    /** Retrieve keys (Consumer key/secret) of application */
    get: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys are returned.
         */
        200: {
          schema: definitions['ApplicationKeyList'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/oauth-keys/{keyMappingId}': {
    /** This operation can be used to retrieve key details of an individual application specifying the key type in the URI. */
    get: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** OAuth Key Identifier consisting of the UUID of the Oauth Key Mapping. */
          keyMappingId: parameters['keyMappingId'];
        };
        query: {
          /** Application Group Id */
          groupId?: parameters['groupId'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys of given type are returned.
         */
        200: {
          schema: definitions['ApplicationKey'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
    /** This operation can be used to update grant types and callback url of an application. (Consumer Key and Consumer Secret are ignored) Upon succesfull you will retrieve the updated key details as the response. */
    put: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** OAuth Key Identifier consisting of the UUID of the Oauth Key Mapping. */
          keyMappingId: parameters['keyMappingId'];
        };
        body: {
          /** Grant types/Callback URL update request object */
          body: definitions['ApplicationKey'];
        };
      };
      responses: {
        /**
         * Ok.
         * Grant types or/and callback url is/are updated.
         */
        200: {
          schema: definitions['ApplicationKey'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/oauth-keys/{keyMappingId}/regenerate-secret': {
    /** This operation can be used to re generate consumer secret for an application for the give key type */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** OAuth Key Identifier consisting of the UUID of the Oauth Key Mapping. */
          keyMappingId: parameters['keyMappingId'];
        };
      };
      responses: {
        /**
         * OK.
         * Keys are re generated.
         */
        200: {
          headers: {};
          schema: definitions['ApplicationKeyReGenerateResponse'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/oauth-keys/{keyMappingId}/clean-up': {
    /** Clean up keys after failed key generation of an application */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** OAuth Key Identifier consisting of the UUID of the Oauth Key Mapping. */
          keyMappingId: parameters['keyMappingId'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Clean up is performed
         */
        200: unknown;
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/oauth-keys/{keyMappingId}/generate-token': {
    /** Generate an access token for application by client_credentials grant type */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** OAuth Key Identifier consisting of the UUID of the Oauth Key Mapping. */
          keyMappingId: parameters['keyMappingId'];
        };
        body: {
          /** Application token generation request object */
          body: definitions['ApplicationTokenGenerateRequest'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Token is generated.
         */
        200: {
          schema: definitions['ApplicationToken'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/api-keys/{keyType}/generate': {
    /** Generate a self contained API Key for the application */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox). */
          keyType: parameters['keyType'];
        };
        body: {
          /** API Key generation request object */
          body?: definitions['APIKeyGenerateRequest'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * apikey generated.
         */
        200: {
          schema: definitions['APIKey'];
        };
        400: responses['BadRequest'];
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/applications/{applicationId}/api-keys/{keyType}/revoke': {
    /** Revoke a self contained API Key for the application */
    post: {
      parameters: {
        path: {
          /** Application Identifier consisting of the UUID of the Application. */
          applicationId: parameters['applicationId'];
          /** **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox). */
          keyType: parameters['keyType'];
        };
        body: {
          /** API Key revoke request object */
          body?: definitions['APIKeyRevokeRequest'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * apikey revoked successfully.
         */
        200: unknown;
        400: responses['BadRequest'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/subscriptions': {
    /**
     * This operation can be used to retrieve a list of subscriptions of the user associated with the provided access token. This operation is capable of
     *
     * 1. Retrieving applications which are subscibed to a specific API.
     * `GET https://localhost:9443/api/am/store/v1/subscriptions?apiId=c43a325c-260b-4302-81cb-768eafaa3aed`
     *
     * 2. Retrieving APIs which are subscribed by a specific application.
     * `GET https://localhost:9443/api/am/store/v1/subscriptions?applicationId=c43a325c-260b-4302-81cb-768eafaa3aed`
     *
     * **IMPORTANT:**
     * * It is mandatory to provide either **apiId** or **applicationId**.
     */
    get: {
      parameters: {
        query: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId?: parameters['apiId-Q'];
          /** **Application Identifier** consisting of the UUID of the Application. */
          applicationId?: parameters['applicationId-Q'];
          /** Application Group Id */
          groupId?: parameters['groupId'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Subscription list returned.
         */
        200: {
          headers: {};
          schema: definitions['SubscriptionList'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        406: responses['NotAcceptable'];
      };
    };
    /** This operation can be used to add a new subscription providing the id of the API and the application. */
    post: {
      parameters: {
        body: {
          /** Subscription object that should to be added */
          body: definitions['Subscription'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created object as entity in the body.
         * Location header contains URL of newly created entity.
         */
        201: {
          headers: {};
          schema: definitions['Subscription'];
        };
        /**
         * Accepted.
         * The request has been accepted.
         */
        202: {
          headers: {};
          schema: definitions['WorkflowResponse'];
        };
        400: responses['BadRequest'];
        /**
         * Unsupported media type.
         * The entity of the request was in a not supported format.
         */
        415: unknown;
      };
    };
  };
  '/subscriptions/multiple': {
    /** This operation can be used to add a new subscriptions providing the ids of the APIs and the applications. */
    post: {
      parameters: {
        body: {
          /** Subscription objects that should to be added */
          body: definitions['Subscription'][];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * Successful response with the newly created objects as entity in the body.
         */
        200: {
          headers: {};
          schema: definitions['Subscription'][];
        };
        400: responses['BadRequest'];
        /**
         * Unsupported media type.
         * The entity of the request was in a not supported format.
         */
        415: unknown;
      };
    };
  };
  '/subscriptions/{subscriptionId}': {
    /** This operation can be used to get details of a single subscription. */
    get: {
      parameters: {
        path: {
          /** Subscription Id */
          subscriptionId: parameters['subscriptionId'];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Subscription returned
         */
        200: {
          headers: {};
          schema: definitions['Subscription'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
      };
    };
    /** This operation can be used to update a subscription providing the subscription id, api id, application Id, status and updated throttling policy tier. */
    put: {
      parameters: {
        body: {
          /** Subscription object that should to be added */
          body: definitions['Subscription'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
        path: {
          /** Subscription Id */
          subscriptionId: parameters['subscriptionId'];
        };
      };
      responses: {
        /**
         * Subscription Updated.
         * Successful response with the updated object as entity in the body.
         * Location header contains URL of newly updates entity.
         */
        200: {
          headers: {};
          schema: definitions['Subscription'];
        };
        /**
         * Accepted.
         * The request has been accepted.
         */
        202: {
          headers: {};
          schema: definitions['WorkflowResponse'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        400: responses['BadRequest'];
        /**
         * Not Found.
         * Requested Subscription does not exist.
         */
        404: unknown;
        /**
         * Unsupported media type.
         * The entity of the request was in a not supported format.
         */
        415: unknown;
      };
    };
    /** This operation can be used to remove a subscription. */
    delete: {
      parameters: {
        path: {
          /** Subscription Id */
          subscriptionId: parameters['subscriptionId'];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          'If-Match'?: parameters['If-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Resource successfully deleted.
         */
        200: unknown;
        /**
         * Accepted.
         * The request has been accepted.
         */
        202: {
          headers: {};
          schema: definitions['WorkflowResponse'];
        };
        404: responses['NotFound'];
        412: responses['PreconditionFailed'];
      };
    };
  };
  '/subscriptions/{subscriptionId}/usage': {
    /** This operation can be used to get details of a pending invoice for a monetized subscription with metered billing. */
    get: {
      parameters: {
        path: {
          /** Subscription Id */
          subscriptionId: parameters['subscriptionId'];
        };
      };
      responses: {
        /**
         * OK.
         * Details of a pending invoice returned.
         */
        200: {
          headers: {};
          schema: definitions['APIMonetizationUsage'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses['NotFound'];
      };
    };
  };
  '/throttling-policies/{policyLevel}': {
    /** Get available Throttling Policies */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
        };
        path: {
          /** List Application or Subscription type thro. */
          policyLevel: parameters['policyLevel'];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * List of throttling policies returned.
         */
        200: {
          headers: {};
          schema: definitions['ThrottlingPolicyList'][];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        406: responses['NotAcceptable'];
      };
    };
  };
  '/throttling-policies/{policyLevel}/{policyId}': {
    /**
     * This operation can be used to retrieve details of a single throttling policy by specifying the policy level and policy name.
     *
     * `X-WSO2-Tenant` header can be used to retrive throttling policy that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     */
    get: {
      parameters: {
        path: {
          /** The name of the policy */
          policyId: parameters['policyId'];
          /** List Application or Subscription type thro. */
          policyLevel: parameters['policyLevel'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Throttling Policy returned
         */
        200: {
          headers: {};
          schema: definitions['ThrottlingPolicy'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/tags': {
    /**
     * This operation can be used to retrieve a list of tags that are already added to APIs.
     *
     * `X-WSO2-Tenant` header can be used to retrive tags that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     *
     * **NOTE:**
     * * This operation does not require an Authorization header by default. But in order to see a restricted API's tags, you need to provide Authorization header.
     */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Tag list is returned.
         */
        200: {
          headers: {};
          schema: definitions['TagList'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/search': {
    /** This operation provides you a list of available APIs and API Documents qualifying the given keyword match. */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
          /**
           * **Search**.
           *
           * You can search by using providing the search term in the query parameters.
           */
          query?: string;
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * List of qualifying APIs and docs is returned.
         */
        200: {
          headers: {};
          schema: definitions['SearchResultList'];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        406: responses['NotAcceptable'];
      };
    };
  };
  '/sdk-gen/languages': {
    /** This operation will provide a list of programming languages that are supported by the swagger codegen library for generating System Development Kits (SDKs) for APIs available in the API Manager Developer Portal */
    get: {
      responses: {
        /**
         * OK.
         * List of supported languages for generating SDKs.
         */
        200: unknown;
        404: responses['NotFound'];
        500: responses['InternalServerError'];
      };
    };
  };
  '/settings': {
    /** Retrieve store settings */
    get: {
      parameters: {
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * Settings returned
         */
        200: {
          schema: definitions['Settings'];
        };
        404: responses['NotFound'];
      };
    };
  };
  '/settings/application-attributes': {
    /** This operation can be used to retrieve the application attributes from configuration. It will not return hidden attributes. */
    get: {
      parameters: {
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resourec.
           */
          'If-None-Match'?: parameters['If-None-Match'];
        };
      };
      responses: {
        /**
         * OK.
         * Application attributes returned.
         */
        200: {
          headers: {};
          schema: definitions['ApplicationAttributeList'];
        };
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/tenants': {
    /** This operation is to get tenants by state */
    get: {
      parameters: {
        query: {
          /**
           * The state represents the current state of the tenant
           *
           * Supported states are [ active, inactive]
           */
          state?: 'active' | 'inactive';
          /** Maximum size of resource array to return. */
          limit?: parameters['limit'];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters['offset'];
        };
      };
      responses: {
        /**
         * OK.
         * Tenant names returned.
         */
        200: {
          headers: {};
          schema: definitions['TenantList'];
        };
        404: responses['NotFound'];
        406: responses['NotAcceptable'];
      };
    };
  };
  '/recommendations': {
    /** This API can be used to get recommended APIs for a user who logs into the API Developer Portal */
    get: {
      responses: {
        /**
         * OK.
         * Requested recommendations are returned
         */
        200: {
          headers: {};
          schema: definitions['Recommendations'];
        };
        404: responses['NotFound'];
      };
    };
  };
  '/alert-types': {
    /** This operation is used to get the list of supportd alert types for the 'subscriber' agent. */
    get: operations['getStoreAlertTypes'];
  };
  '/alert-subscriptions': {
    /** This operation is used to get the list of subscribed alert types by the user. */
    get: operations['getSubscribedAlertTypes'];
    /** This operation is used to susbscribe to the selected alert types by the user. */
    put: operations['subscribeToAlerts'];
    /** This operation is used to unsubscribe the respective user from all the alert types. */
    delete: operations['unsubscribeAllAlerts'];
  };
  '/alerts/{alertType}/configurations': {
    /** This operation is used to get all configurations of the AbnormalRequestsPerMin alert type. */
    get: operations['getAllAlertConfigs'];
  };
  '/alerts/{alertType}/configurations/{configurationId}': {
    /** This operation is used to add configuration for the AbnormalRequestsPerMin alert type. */
    put: operations['addAlertConfig'];
    /** This operation is used to delete configuration from the AbnormalRequestsPerMin alert type. */
    delete: operations['deleteAlertConfig'];
  };
  '/api-categories': {
    /** Get all API categories */
    get: {
      parameters: {
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * Categories returned
         */
        200: {
          schema: definitions['APICategoryList'];
        };
      };
    };
  };
  '/key-managers': {
    /** Get all Key managers */
    get: {
      parameters: {
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           * retrieved from.
           */
          'X-WSO2-Tenant'?: parameters['requestedTenant'];
        };
      };
      responses: {
        /**
         * OK.
         * Categories returned
         */
        200: {
          schema: definitions['KeyManagerList'];
        };
      };
    };
  };
  '/apis/{apiId}/graphql-policies/complexity': {
    /** This operation can be used to retrieve complexity related details belonging to an API by providing the API id. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
      };
      responses: {
        /**
         * OK.
         * Requested complexity details returned.
         */
        200: unknown;
        /**
         * Not Found.
         * Requested API does not contain any complexity details.
         */
        404: unknown;
      };
    };
  };
  '/apis/{apiId}/graphql-policies/complexity/types': {
    /** This operation can be used to retrieve all types and fields of the GraphQL Schema by providing the API id. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters['apiId'];
        };
      };
      responses: {
        /**
         * OK.
         * Types and fields returned successfully.
         */
        200: {
          headers: {};
          schema: definitions['GraphQLSchemaTypeList'];
        };
        /**
         * Not Found.
         * Retrieving types and fields failed.
         */
        404: unknown;
      };
    };
  };
  '/me/change-password': {
    /** Using this operation, logged-in user can change their password. */
    post: operations['changeUserPassword'];
  };
}

export interface definitions {
  /**
   * API List
   * @example {
   *   "count": 2,
   *   "list": [
   *     {
   *       "id": "01234567-0123-0123-0123-012345678901",
   *       "name": "CalculatorAPI",
   *       "description": "A calculator API that supports basic operations",
   *       "context": "/CalculatorAPI",
   *       "version": "1.0.0",
   *       "provider": "admin",
   *       "lifeCycleStatus": "PUBLISHED",
   *       "thumbnailUri": "/apis/01234567-0123-0123-0123-012345678901/thumbnail"
   *     },
   *     {
   *       "id": "01123567-1233-5453-0212-12353678901",
   *       "name": "PizzaShackAPI",
   *       "description": "A Pizza ordering API",
   *       "context": "/PizzaShackAPI",
   *       "version": "1.0.0",
   *       "provider": "admin",
   *       "lifeCycleStatus": "PUBLISHED",
   *       "thumbnailUri": "/apis/01123567-1233-5453-0212-12353678901/thumbnail"
   *     }
   *   ],
   *   "pagination": {
   *     "offset": 2,
   *     "limit": 2,
   *     "total": 10,
   *     "next": "/apis?limit=2&offset=4",
   *     "previous": "/apis?limit=2&offset=0"
   *   }
   * }
   */
  APIList: {
    /**
     * @description Number of APIs returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['APIInfo'][];
    pagination?: definitions['Pagination'];
  };
  /** API Info object with basic API details. */
  APIInfo: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example CalculatorAPI */
    name?: string;
    /** @example A calculator API that supports basic operations */
    description?: string;
    /** @example CalculatorAPI */
    context?: string;
    /** @example 1.0.0 */
    version?: string;
    /** @example WS */
    type?: string;
    /**
     * @description If the provider value is not given, the user invoking the API will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /** @example PUBLISHED */
    lifeCycleStatus?: string;
    /** @example /apis/01234567-0123-0123-0123-012345678901/thumbnail */
    thumbnailUri?: string;
    /**
     * @description Average rating of the API
     * @example 4.5
     */
    avgRating?: string;
    /**
     * @description List of throttling policies of the API
     * @example [
     *   "Unlimited",
     *   "Bronze"
     * ]
     */
    throttlingPolicies?: string[];
    /** @description The advertise info of the API */
    advertiseInfo?: definitions['AdvertiseInfo'];
    businessInformation?: definitions['APIBusinessInformation'];
    /** @example false */
    isSubscriptionAvailable?: boolean;
    /** @example Free */
    monetizationLabel?: string;
  };
  /** API object */
  API: {
    /**
     * @description UUID of the api
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id?: string;
    /**
     * @description Name of the API
     * @example CalculatorAPI
     */
    name: string;
    /**
     * @description A brief description about the API
     * @example A calculator API that supports basic operations
     */
    description?: string;
    /**
     * @description A string that represents thecontext of the user's request
     * @example CalculatorAPI
     */
    context: string;
    /**
     * @description The version of the API
     * @example 1.0.0
     */
    version: string;
    /**
     * @description If the provider value is not given user invoking the api will be used as the provider.
     *
     * @example admin
     */
    provider: string;
    /**
     * @description Swagger definition of the API which contains details about URI templates and scopes
     *
     * @example {"paths":{"\/substract":{"get":{"x-auth-type":"Application & Application User","x-throttling-tier":"Unlimited","parameters":[{"name":"x","required":true,"type":"string","in":"query"},{"name":"y","required":true,"type":"string","in":"query"}],"responses":{"200":{}}}},"\/add":{"get":{"x-auth-type":"Application & Application User","x-throttling-tier":"Unlimited","parameters":[{"name":"x","required":true,"type":"string","in":"query"},{"name":"y","required":true,"type":"string","in":"query"}],"responses":{"200":{}}}}},"swagger":"2.0","info":{"title":"CalculatorAPI","version":"1.0.0"}}
     */
    apiDefinition?: string;
    /**
     * @description WSDL URL if the API is based on a WSDL endpoint
     *
     * @example http://www.webservicex.com/globalweather.asmx?wsdl
     */
    wsdlUri?: string;
    /**
     * @description This describes in which status of the lifecycle the API is.
     * @example PUBLISHED
     */
    lifeCycleStatus: string;
    /** @example false */
    isDefaultVersion?: boolean;
    /**
     * @description This describes the transport type of the API
     * @example WS
     */
    type?: string;
    /**
     * @example [
     *   "http",
     *   "https"
     * ]
     */
    transport?: string[];
    /** @example [] */
    operations?: definitions['APIOperations'][];
    /**
     * @description Name of the Authorization header used for invoking the API. If it is not set, Authorization header name specified
     * in tenant or system level will be used.
     *
     * @example Authorization
     */
    authorizationHeader?: string;
    /**
     * @description Types of API security, the current API secured with. It can be either OAuth2 or mutual SSL or both. If
     * it is not set OAuth2 will be set as the security for the current API.
     *
     * @example [
     *   "oauth2",
     *   "oauth_basic_auth_api_key_mandatory"
     * ]
     */
    securityScheme?: string[];
    /**
     * @description Search keywords related to the API
     * @example [
     *   "substract",
     *   "add"
     * ]
     */
    tags?: string[];
    /** @description The subscription tiers selected for the particular API */
    tiers?: {
      /** @example Gold */
      tierName?: string;
      /** @example COMMERCIAL */
      tierPlan?: string;
      monetizationAttributes?: {
        /** @example 10 */
        fixedPrice?: string;
        /** @example 1 */
        pricePerRequest?: string;
        /** @example USD */
        currencyType?: string;
        /** @example month */
        billingCycle?: string;
      };
    }[];
    /**
     * @default false
     * @example true
     */
    hasThumbnail?: boolean;
    /**
     * @description Custom(user defined) properties of API
     *
     * @example {}
     */
    additionalProperties?: { [key: string]: string };
    monetization?: definitions['APIMonetizationInfo'];
    ingressURLs?: {
      /** @example kubernetes */
      deploymentEnvironmentName?: string;
      clusterDetails?: definitions['APIDeploymentClusterInfo'][];
    }[];
    endpointURLs?: {
      /** @example Production and Sandbox */
      environmentName?: string;
      /** @example hybrid */
      environmentType?: string;
      URLs?: {
        /**
         * @description HTTP environment URL
         * @example http://localhost:8280/phoneverify/1.0.0
         */
        http?: string;
        /**
         * @description HTTPS environment URL
         * @example https://localhost:8243/phoneverify/1.0.0
         */
        https?: string;
        /**
         * @description WS environment URL
         * @example ws://localhost:9099/phoneverify/1.0.0
         */
        ws?: string;
        /**
         * @description WSS environment URL
         * @example wss://localhost:9099/phoneverify/1.0.0
         */
        wss?: string;
      };
      defaultVersionURLs?: {
        /**
         * @description HTTP environment default URL
         * @example http://localhost:8280/phoneverify/
         */
        http?: string;
        /**
         * @description HTTPS environment default URL
         * @example https://localhost:8243/phoneverify/
         */
        https?: string;
        /**
         * @description WS environment default URL
         * @example ws://localhost:9099/phoneverify/
         */
        ws?: string;
        /**
         * @description WSS environment default URL
         * @example ws://localhost:9099/phoneverify/
         */
        wss?: string;
      };
    }[];
    businessInformation?: definitions['APIBusinessInformation'];
    /** @description Labels of micro-gateway environments attached to the API. */
    labels?: definitions['Label'][];
    /**
     * @description The environment list configured with non empty endpoint URLs for the particular API.
     * @example [
     *   "PRODUCTION",
     *   "SANDBOX"
     * ]
     */
    environmentList?: string[];
    scopes?: definitions['ScopeInfo'][];
    /**
     * @description The average rating of the API
     * @example 4.5
     */
    avgRating?: string;
    /** @description The advertise info of the API */
    advertiseInfo?: definitions['AdvertiseInfo'];
    /** @example false */
    isSubscriptionAvailable?: boolean;
    /** @description API categories */
    categories?: string[];
    /** @description API Key Managers */
    keyManagers?: { [key: string]: unknown };
  };
  /** Label */
  Label: {
    /** @example Public */
    name: string;
    description?: string;
    accessUrls?: string[];
  };
  /** API monetization object */
  APIMonetizationInfo: {
    /**
     * @description Flag to indicate the monetization status
     * @example true
     */
    enabled: boolean;
  };
  /** Application List */
  ApplicationList: {
    /**
     * @description Number of applications returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['ApplicationInfo'][];
    pagination?: definitions['Pagination'];
  };
  /** Application */
  Application: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    applicationId?: string;
    /** @example CalculatorApp */
    name: string;
    /** @example Unlimited */
    throttlingPolicy: string;
    /** @example Sample calculator application */
    description?: string;
    /**
     * @description Type of the access token generated for this application.
     *
     * **JWT:** A self-contained, signed JWT based access token which is issued by default.
     *
     * @default JWT
     * @example JWT
     * @enum {string}
     */
    tokenType?: 'JWT';
    /**
     * @default
     * @example APPROVED
     */
    status?: string;
    /** @example [] */
    groups?: string[];
    subscriptionCount?: number;
    /** @example {} */
    attributes?: { [key: string]: string };
    /** @example [] */
    subscriptionScopes?: definitions['ScopeInfo'][];
    /**
     * @description Application created user
     *
     * @example admin
     */
    owner?: string;
    /** @example false */
    hashEnabled?: boolean;
  };
  /** Application info object with basic application details */
  ApplicationInfo: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    applicationId?: string;
    /** @example CalculatorApp */
    name?: string;
    /** @example Unlimited */
    throttlingPolicy?: string;
    /** @example Sample calculator application */
    description?: string;
    /**
     * @default
     * @example APPROVED
     */
    status?: string;
    /** @example */
    groups?: string[];
    subscriptionCount?: number;
    /** @example External Reference ID, Billing Tier */
    attributes?: { [key: string]: unknown };
    /** @example admin */
    owner?: string;
  };
  /** Document List */
  DocumentList: {
    /**
     * @description Number of Documents returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['Document'][];
    pagination?: definitions['Pagination'];
  };
  /** Document */
  Document: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    documentId?: string;
    /** @example CalculatorDoc */
    name: string;
    /**
     * @example HOWTO
     * @enum {string}
     */
    type:
      | 'HOWTO'
      | 'SAMPLES'
      | 'PUBLIC_FORUM'
      | 'SUPPORT_FORUM'
      | 'API_MESSAGE_FORMAT'
      | 'SWAGGER_DOC'
      | 'OTHER';
    /** @example Summary of Calculator Documentation */
    summary?: string;
    /**
     * @example INLINE
     * @enum {string}
     */
    sourceType: 'INLINE' | 'MARKDOWN' | 'URL' | 'FILE';
    /** @example */
    sourceUrl?: string;
    /** @example */
    otherTypeName?: string;
  };
  /** Throttling Policy List */
  ThrottlingPolicyList: {
    /**
     * @description Number of Throttling Policies returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['ThrottlingPolicy'][];
    pagination?: definitions['Pagination'];
  };
  /** Throttling Policy */
  ThrottlingPolicy: {
    /** @example Platinum */
    name: string;
    /** @example Allows 50 request(s) per minute. */
    description?: string;
    /**
     * @example subscription
     * @enum {string}
     */
    policyLevel?: 'application' | 'subscription';
    /**
     * @description Custom attributes added to the throttling policy
     *
     * @example {}
     */
    attributes?: { [key: string]: string };
    /**
     * Format: int64
     * @description Maximum number of requests which can be sent within a provided unit time
     *
     * @example 50
     */
    requestCount: number;
    /**
     * Format: int64
     * @example 60000
     */
    unitTime: number;
    /**
     * @description This attribute declares whether this tier is available under commercial or free
     *
     * @example FREE
     * @enum {string}
     */
    tierPlan: 'FREE' | 'COMMERCIAL';
    /**
     * @description If this attribute is set to false, you are capabale of sending requests
     * even if the request count exceeded within a unit time
     *
     * @example true
     */
    stopOnQuotaReach: boolean;
    monetizationAttributes?: definitions['MonetizationInfo'];
    throttlingPolicyPermissions?: definitions['ThrottlingPolicyPermissionInfo'];
  };
  /** Subscription List */
  SubscriptionList: {
    /**
     * @description Number of Subscriptions returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['Subscription'][];
    pagination?: definitions['Pagination'];
  };
  APIBusinessInformation: {
    /** @example businessowner */
    businessOwner?: string;
    /** @example businessowner@wso2.com */
    businessOwnerEmail?: string;
    /** @example technicalowner */
    technicalOwner?: string;
    /** @example technicalowner@wso2.com */
    technicalOwnerEmail?: string;
  };
  /** Subscription */
  Subscription: {
    /**
     * @description The UUID of the subscription
     * @example faae5fcc-cbae-40c4-bf43-89931630d313
     */
    subscriptionId?: string;
    /**
     * @description The UUID of the application
     * @example b3ade481-30b0-4b38-9a67-498a40873a6d
     */
    applicationId: string;
    /**
     * @description The unique identifier of the API.
     * @example 2962f3bb-8330-438e-baee-0ee1d6434ba4
     */
    apiId?: string;
    apiInfo?: definitions['APIInfo'];
    applicationInfo?: definitions['ApplicationInfo'];
    /** @example Unlimited */
    throttlingPolicy: string;
    /** @example Unlimited */
    requestedThrottlingPolicy?: string;
    /**
     * @example UNBLOCKED
     * @enum {string}
     */
    status?:
      | 'BLOCKED'
      | 'PROD_ONLY_BLOCKED'
      | 'UNBLOCKED'
      | 'ON_HOLD'
      | 'REJECTED'
      | 'TIER_UPDATE_PENDING';
    /**
     * @description A url and other parameters the subscriber can be redirected.
     * @example
     */
    redirectionParams?: string;
  } & {
    apiName: unknown;
    apiVersion: unknown;
  };
  /** Tag */
  Tag: {
    /** @example tag1 */
    value?: string;
    /** @example 5 */
    count?: number;
  } & {
    name: unknown;
    weight: unknown;
  };
  /** Tag List */
  TagList: {
    /**
     * @description Number of Tags returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['Tag'][];
    pagination?: definitions['Pagination'];
  };
  /** Rating */
  Rating: {
    /** @example 32acfa7a-77f8-4fe0-bb7f-a902f36546d0 */
    ratingId?: string;
    /** @example e93fb282-b456-48fc-8981-003fb89086ae */
    apiId?: string;
    /** @example admin */
    ratedBy?: string;
    /** @example 4 */
    rating: number;
  };
  /** Rating List */
  RatingList: {
    /**
     * @description Average Rating of the API
     *
     * @example 4
     */
    avgRating?: string;
    /**
     * @description Rating given by the user
     *
     * @example 4
     */
    userRating?: number;
    /**
     * @description Number of Subscriber Ratings returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['Rating'][];
    pagination?: definitions['Pagination'];
  };
  /** Comment */
  Comment: {
    /** @example 943d3002-000c-42d3-a1b9-d6559f8a4d49 */
    id?: string;
    /** @example This is a comment */
    content: string;
    /** @example 2017-02-20T13:57:16.229Z */
    createdTime?: string;
    /** @example admin */
    createdBy?: string;
  };
  /** Comments List */
  CommentList: {
    /**
     * @description Number of Comments returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['Comment'][];
    pagination?: definitions['Pagination'];
  };
  /** Error object returned with 4XX HTTP status */
  Error: {
    /** Format: int64 */
    code: number;
    /** @description Error message. */
    message: string;
    /** @description A detail description about the error message. */
    description?: string;
    /** @description Preferably an url with more details about the error. */
    moreInfo?: string;
    /**
     * @description If there are more than one error list them out.
     * For example, list out validation errors by each field.
     */
    error?: definitions['ErrorListItem'][];
  };
  /** Description of individual errors that may have occurred during a request. */
  ErrorListItem: {
    code: string;
    /** @description Description about individual errors occurred */
    message: string;
  };
  /** Application token details to invoke APIs */
  ApplicationToken: {
    /**
     * @description Access token
     * @example 1.2345678901234568e+30
     */
    accessToken?: string;
    /**
     * @description Valid comma seperated scopes for the access token
     * @example [
     *   "default",
     *   "read_api",
     *   "write_api"
     * ]
     */
    tokenScopes?: string[];
    /**
     * Format: int64
     * @description Maximum validity time for the access token
     * @example 3600
     */
    validityTime?: number;
  };
  /** API Key details to invoke APIs */
  APIKey: {
    /**
     * @description API Key
     * @example eyJoZWxsbyI6IndvcmxkIn0=.eyJ3c28yIjoiYXBpbSJ9.eyJ3c28yIjoic2lnbmF0dXJlIn0=
     */
    apikey?: string;
    /**
     * Format: int32
     * @example 3600
     */
    validityTime?: number;
  };
  /** Application key details */
  ApplicationKey: {
    /**
     * @description Key Manager Mapping UUID
     * @example 92ab520c-8847-427a-a921-3ed19b15aad7
     */
    keyMappingId?: string;
    /**
     * @description Key Manager Name
     * @example Resident Key Manager
     */
    keyManager?: string;
    /**
     * @description Consumer key of the application
     * @example vYDoc9s7IgAFdkSyNDaswBX7ejoa
     */
    consumerKey?: string;
    /**
     * @description Consumer secret of the application
     * @example TIDlOFkpzB7WjufO3OJUhy1fsvAa
     */
    consumerSecret?: string;
    /**
     * @description The grant types that are supported by the application
     * @example [
     *   "client_credentials",
     *   "password"
     * ]
     */
    supportedGrantTypes?: string[];
    /**
     * @description Callback URL
     * @example http://sample.com/callback/url
     */
    callbackUrl?: string;
    /**
     * @description Describes the state of the key generation.
     * @example APPROVED
     */
    keyState?: string;
    /**
     * @description Describes to which endpoint the key belongs
     * @example PRODUCTION
     * @enum {string}
     */
    keyType?: 'PRODUCTION' | 'SANDBOX';
    /**
     * @description Application group id (if any).
     * @example 2
     */
    groupId?: string;
    token?: definitions['ApplicationToken'];
    /** @description additionalProperties (if any). */
    additionalProperties?: { [key: string]: unknown };
  };
  /** Application key details after re generating consumer secret */
  ApplicationKeyReGenerateResponse: {
    /**
     * @description The consumer key associated with the application, used to indetify the client
     * @example vYDoc9s7IgAFdkSyNDaswBX7ejoa
     */
    consumerKey?: string;
    /**
     * @description The client secret that is used to authenticate the client with the authentication server
     * @example TIDlOFkpzB7WjufO3OJUhy1fsvAa
     */
    consumerSecret?: string;
  };
  /** Application Keys List */
  ApplicationKeyList: {
    /**
     * @description Number of applications keys returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['ApplicationKey'][];
  };
  /** Application key generation request object */
  ApplicationKeyGenerateRequest: {
    /** @enum {string} */
    keyType: 'PRODUCTION' | 'SANDBOX';
    /**
     * @description key Manager to Generate Keys
     * @example Resident Key Manager
     */
    keyManager?: string;
    /**
     * @description Grant types that should be supported by the application
     * @example [
     *   "password",
     *   "client_credentials"
     * ]
     */
    grantTypesToBeSupported: string[];
    /**
     * @description Callback URL
     * @example http://sample.com/callback/url
     */
    callbackUrl?: string;
    /**
     * @description Allowed scopes for the access token
     * @example [
     *   "am_application_scope",
     *   "default"
     * ]
     */
    scopes?: string[];
    /** @example 3600 */
    validityTime?: string;
    /**
     * @description Client ID for generating access token.
     * @example sZzoeSCI_vL2cjSXZQmsmV8JEyga
     */
    clientId?: string;
    /**
     * @description Client secret for generating access token. This is given together with the client Id.
     * @example nrs3YAP4htxnz_DqpvGhf9Um04oa
     */
    clientSecret?: string;
    /**
     * @description Additional properties needed.
     * @example {}
     */
    additionalProperties?: { [key: string]: unknown };
  };
  /** Application key provision request object */
  ApplicationKeyMappingRequest: {
    /**
     * @description Consumer key of the application
     * @example oYhwZu4P2ThDmiDprBk6c0YfjR8a
     */
    consumerKey: string;
    /**
     * @description Consumer secret of the application
     * @example ondWGtFTCOVM4sfPyOfZ7fel610a
     */
    consumerSecret?: string;
    /**
     * @description Key Manager Name
     * @example Resident Key Manager
     */
    keyManager?: string;
    /** @enum {string} */
    keyType: 'PRODUCTION' | 'SANDBOX';
  };
  /** Application access token generation request object */
  ApplicationTokenGenerateRequest: {
    /**
     * @description Consumer secret of the application
     * @example cV5pvyisxug5b5QZInq9cGZrMOMa
     */
    consumerSecret?: string;
    /**
     * Format: int64
     * @description Token validity period
     * @example 3600
     */
    validityPeriod?: number;
    /**
     * @description Allowed scopes (space seperated) for the access token
     * @example [
     *   "apim:subscribe"
     * ]
     */
    scopes?: string[];
    /**
     * @description Token to be revoked, if any
     * @example
     */
    revokeToken?: string;
    /** @description Additional parameters if Authorization server needs any */
    additionalProperties?: { [key: string]: unknown };
  };
  /** API Key generation request object */
  APIKeyGenerateRequest: {
    /**
     * Format: int32
     * @description Token validity period
     * @example 3600
     */
    validityPeriod?: number;
    /** @description Additional parameters if Authorization server needs any */
    additionalProperties?: { [key: string]: unknown };
  };
  /** API Key revoke request object */
  APIKeyRevokeRequest: {
    /**
     * @description API Key to revoke
     * @example eyJoZWxsbyI6IndvcmxkIn0=.eyJ3c28yIjoiYXBpbSJ9.eyJ3c28yIjoic2lnbmF0dXJlIn0=
     */
    apikey?: string;
  };
  /** API Scope info object with scope details */
  ScopeInfo: {
    /** @example admin_scope */
    key?: string;
    /** @example admin scope */
    name?: string;
    /**
     * @description Allowed roles for the scope
     * @example [
     *   "manager",
     *   "developer"
     * ]
     */
    roles?: string[];
    /** @description Description of the scope */
    description?: string;
  };
  /** Scope list */
  ScopeList: {
    /**
     * @description Number of results returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['ScopeInfo'][];
    pagination?: definitions['Pagination'];
  };
  /** Throttling Policy Permission info object with throttling policy permission details */
  ThrottlingPolicyPermissionInfo: {
    /** @enum {string} */
    type?: 'allow' | 'deny';
    /**
     * @description roles for this permission
     * @example [
     *   "manager",
     *   "developer"
     * ]
     */
    roles?: string[];
  };
  /** Monetization */
  MonetizationInfo: {
    /**
     * @example fixedPrice
     * @enum {string}
     */
    billingType?: 'fixedPrice' | 'dynamicRate';
    /** @example month */
    billingCycle?: string;
    /** @example 10 */
    fixedPrice?: string;
    /** @example 1 */
    pricePerRequest?: string;
    /** @example USD */
    currencyType?: string;
  };
  /** API monetization usage object */
  APIMonetizationUsage: {
    /** @description Map of custom properties related to monetization usage */
    properties?: { [key: string]: string };
  };
  /** workflow Response */
  WorkflowResponse: {
    /**
     * @description This attribute declares whether this workflow task is approved or rejected.
     *
     * @example APPROVED
     * @enum {string}
     */
    workflowStatus: 'CREATED' | 'APPROVED' | 'REJECTED' | 'REGISTERED';
    /** @description Attributes that returned after the workflow execution */
    jsonPayload?: string;
  };
  /** User */
  User: {
    username: string;
    password: string;
    firstName: string;
    lastName: string;
    email: string;
  };
  /** Operation */
  APIOperations: {
    /** @example apioperation */
    id?: string;
    target?: string;
    verb?: string;
  };
  /** Search Result List */
  SearchResultList: {
    /**
     * @description Number of results returned.
     *
     * @example 1
     */
    count?: number;
    list?: (Partial<definitions['APISearchResult']> &
      Partial<definitions['DocumentSearchResult']>)[];
    pagination?: definitions['Pagination'];
  };
  /** Search Result */
  SearchResult: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example TestAPI */
    name: string;
    /**
     * @example API
     * @enum {string}
     */
    type?: 'DOC' | 'API';
    /** @description Accepted values are HTTP, WS, SOAPTOREST, GRAPHQL */
    transportType?: string;
  };
  /** API Result */
  APISearchResult: definitions['SearchResult'] & {
    /**
     * @description A brief description about the API
     * @example A calculator API that supports basic operations
     */
    description?: string;
    /**
     * @description A string that represents the context of the user's request
     * @example CalculatorAPI
     */
    context?: string;
    /**
     * @description The version of the API
     * @example 1.0.0
     */
    version?: string;
    /**
     * @description If the provider value is notgiven, the user invoking the API will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /**
     * @description This describes in which status of the lifecycle the API is
     * @example CREATED
     */
    status?: string;
    /** @example /apis/01234567-0123-0123-0123-012345678901/thumbnail */
    thumbnailUri?: string;
    businessInformation?: definitions['APIBusinessInformation'];
    /**
     * @description Average rating of the API
     * @example 4.5
     */
    avgRating?: string;
  };
  /** Document Result */
  DocumentSearchResult: definitions['SearchResult'] & {
    /**
     * @example HOWTO
     * @enum {string}
     */
    docType?:
      | 'HOWTO'
      | 'SAMPLES'
      | 'PUBLIC_FORUM'
      | 'SUPPORT_FORUM'
      | 'API_MESSAGE_FORMAT'
      | 'SWAGGER_DOC'
      | 'OTHER';
    /** @example Summary of Calculator Documentation */
    summary?: string;
    /**
     * @example INLINE
     * @enum {string}
     */
    sourceType?: 'INLINE' | 'URL' | 'FILE' | 'MARKDOWN';
    /** @example */
    sourceUrl?: string;
    /** @example */
    otherTypeName?: string;
    /**
     * @example API_LEVEL
     * @enum {string}
     */
    visibility?: 'OWNER_ONLY' | 'PRIVATE' | 'API_LEVEL';
    /**
     * @description The name of the associated API
     * @example TestAPI
     */
    apiName?: string;
    /**
     * @description The version of the associated API
     * @example 1.0.0
     */
    apiVersion?: string;
    /** @example admin */
    apiProvider?: string;
    apiUUID?: string;
  };
  /** Pagination */
  Pagination: {
    /** @example 0 */
    offset?: number;
    /** @example 1 */
    limit?: number;
    /** @example 10 */
    total?: number;
    /**
     * @description Link to the next subset of resources qualified.
     * Empty if no more resources are to be returned.
     *
     * @example
     */
    next?: string;
    /**
     * @description Link to the previous subset of resources qualified.
     * Empty if current subset is the first subset returned.
     *
     * @example
     */
    previous?: string;
  };
  /** Settings */
  Settings: {
    grantTypes?: string[];
    scopes?: string[];
    /** @default false */
    applicationSharingEnabled?: boolean;
    /** @default false */
    mapExistingAuthApps?: boolean;
    apiGatewayEndpoint?: string;
    /** @default false */
    monetizationEnabled?: boolean;
    /** @default false */
    recommendationEnabled?: boolean;
    /** @default false */
    IsUnlimitedTierPaid?: boolean;
    identityProvider?: {
      /** @default false */
      external?: boolean;
    };
    /** @default true */
    IsAnonymousModeEnabled?: boolean;
    /** @default true */
    IsPasswordChangeEnabled?: boolean;
    /**
     * @description The 'PasswordJavaRegEx' cofigured in the UserStoreManager
     * @example
     */
    userStorePasswordPattern?: string;
    /**
     * @description The regex configured in the Password Policy property 'passwordPolicy.pattern'
     * @example
     */
    passwordPolicyPattern?: string;
    /** @description If Password Policy Feature is enabled, the property 'passwordPolicy.min.length' is returned as the 'passwordPolicyMinLength'. If password policy is not enabled, default value -1 will be returned. And it should be noted that the regex pattern(s) returned in 'passwordPolicyPattern' and 'userStorePasswordPattern' properties too will affect the minimum password length allowed and an intersection of all conditions will be considered finally to validate the password. */
    passwordPolicyMinLength?: number;
    /** @description If Password Policy Feature is enabled, the property 'passwordPolicy.max.length' is returned as the 'passwordPolicyMaxLength'. If password policy is not enabled, default value -1 will be returned. And it should be noted that the regex pattern(s) returned in 'passwordPolicyPattern' and 'userStorePasswordPattern' properties too will affect the maximum password length allowed and an intersection of all conditions will be considered finally to validate the password. */
    passwordPolicyMaxLength?: number;
  };
  /** Application attributes */
  ApplicationAttribute: {
    /**
     * @description description of the application attribute
     * @example Sample description of the attribute
     */
    description?: string;
    /**
     * @description whether this is a required attribute
     * @example false
     */
    required?: string;
    /**
     * @description the name of the attribute
     * @example External Reference Id
     */
    attribute?: string;
    /**
     * @description whether this is a hidden attribute
     * @example false
     */
    hidden?: string;
  };
  /** Application Attributes List */
  ApplicationAttributeList: {
    /**
     * @description Number of application attributes returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['ApplicationAttribute'][];
  };
  /** Tenant */
  Tenant: {
    /**
     * @description tenant domain
     * @example wso2.com
     */
    domain?: string;
    /**
     * @description current status of the tenant active/inactive
     * @example active
     */
    status?: string;
  };
  /** Tenant list */
  TenantList: {
    /**
     * @description Number of tenants returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['Tenant'][];
    pagination?: definitions['Pagination'];
  };
  /** API Advertise info object with advertise details */
  AdvertiseInfo: {
    /** @example true */
    advertised?: boolean;
    /** @example https://localhost:9443/store */
    originalStoreUrl?: string;
    /** @example admin */
    apiOwner?: string;
  };
  /** Alert Types List */
  AlertTypesList: {
    /**
     * @description The number of alerts
     * @example 3
     */
    count?: number;
    alerts?: definitions['AlertType'][];
  };
  /** Alert Type */
  AlertType: {
    /**
     * @description The alert Id
     * @example 3
     */
    id?: number;
    /**
     * @description The name of the alert.
     * @example AbnormalRequestsPerMin
     */
    name?: string;
    /**
     * @description Whether the alert type require additional configurations.
     * @example true
     */
    requireConfiguration?: boolean;
  };
  /** Alert */
  Alert: {
    /**
     * @description The alert Id
     * @example 1
     */
    id?: number;
    /**
     * @description The name of the alert.
     * @example AbnormalRequestsPerMin
     */
    name?: string;
    configuration?: definitions['AlertConfig'][];
  };
  /** Alerts Info */
  AlertsInfo: {
    alerts?: definitions['Alert'][];
    /**
     * @example [
     *   "abc@gmail.com"
     * ]
     */
    emailList?: string[];
  };
  /** Alerts Info Response */
  AlertsInfoResponse: {
    alerts?: definitions['Alert'][];
    /**
     * @example [
     *   "abc@gmail.com"
     * ]
     */
    emailList?: string[];
    failedConfigurations?: definitions['AlertConfig'][];
  };
  /** Alert Configuration List */
  AlertConfigList: {
    /** @example 1 */
    count?: number;
    list?: definitions['AlertConfig'][];
  };
  /** Alert Configuration */
  AlertConfig: {
    /**
     * @description The alert config subscription id.
     * @example UGl6emFTaGFja0FQSSsxLjAuMCtEZWZhdWx0QXBwbGljYXRpb24K
     */
    configurationId?: string;
    /**
     * @description The config parameters.
     * @example {
     *   "apiName": "PizzaShackAPI",
     *   "apiVersion": "1.0.0",
     *   "applicationName": "DefaultApplication",
     *   "requestCount": 12
     * }
     */
    configuration?: { [key: string]: string };
  };
  /**
   * Alert Configuration Info
   * @description The config parameters.
   * @example {
   *   "apiName": "PizzaShackAPI",
   *   "apiVersion": "1.0.0",
   *   "applicationName": "DefaultApplication",
   *   "requestCount": "12"
   * }
   */
  AlertConfigInfo: { [key: string]: string };
  /** API Category */
  APICategory: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example Finance */
    name: string;
    /** @example Finance related APIs */
    description?: string;
  };
  /** API Category List */
  APICategoryList: {
    /**
     * @description Number of API categories returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['APICategory'][];
  };
  /** API recommendations */
  Recommendations: {
    /**
     * @description Number of APIs returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['recommendedAPI'][];
  };
  /** Recommended API */
  recommendedAPI: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example CalculatorAPI */
    name?: string;
    /**
     * @description Average rating of the API
     * @example 4.5
     */
    avgRating?: string;
  };
  /** Key Manager Info */
  KeyManagerInfo: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example Resident Key Manager */
    name: string;
    /** @example default */
    type: string;
    /**
     * @description display name of Keymanager
     *
     * @example Resident Key Manager
     */
    displayName?: string;
    /** @example This is Resident Key Manager */
    description?: string;
    /** @example true */
    enabled?: boolean;
    availableGrantTypes?: string[];
    /** @example https://localhost:9443/oauth2/token */
    tokenEndpoint?: string;
    /** @example https://localhost:9443/oauth2/revoke */
    revokeEndpoint?: string;
    /** @example */
    userInfoEndpoint?: string;
    /** @example true */
    enableTokenGeneration?: boolean;
    /**
     * @default false
     * @example false
     */
    enableTokenEncryption?: boolean;
    /**
     * @default false
     * @example false
     */
    enableTokenHashing?: boolean;
    /**
     * @default true
     * @example true
     */
    enableOAuthAppCreation?: boolean;
    /**
     * @default false
     * @example false
     */
    enableMapOAuthConsumerApps?: boolean;
    applicationConfiguration?: definitions['KeyManagerApplicationConfiguration'][];
    additionalProperties?: { [key: string]: unknown };
  };
  /** Key Manager application Configuration */
  KeyManagerApplicationConfiguration: {
    /** @example consumer_key */
    name?: string;
    /** @example Consumer Key */
    label?: string;
    /** @example select */
    type?: string;
    /** @example true */
    required?: boolean;
    /** @example true */
    mask?: boolean;
    /** @example true */
    multiple?: boolean;
    /** @example Enter username to connect to key manager */
    tooltip?: string;
    /** @example admin */
    default?: { [key: string]: unknown };
    values?: { [key: string]: unknown }[];
  };
  /** Key Manager List */
  KeyManagerList: {
    /**
     * @description Number of Key managers returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions['KeyManagerInfo'][];
  };
  /** GraphQL Query Complexity Info */
  GraphQLQueryComplexityInfo: {
    list?: definitions['GraphQLCustomComplexityInfo'][];
  };
  /** GraphQL Custom Complexity Info */
  GraphQLCustomComplexityInfo: {
    /**
     * @description The type found within the schema of the API
     *
     * @example Country
     */
    type: string;
    /**
     * @description The field which is found under the type within the schema of the API
     *
     * @example name
     */
    field: string;
    /**
     * @description The complexity value allocated for the associated field under the specified type
     *
     * @example 1
     */
    complexityValue: number;
  };
  /** List of types and corresponding fields of the GraphQL Schema */
  GraphQLSchemaTypeList: {
    typeList?: definitions['GraphQLSchemaType'][];
  };
  /** Single type and corresponding fields found within the GraphQL Schema */
  GraphQLSchemaType: {
    /**
     * @description Type found within the GraphQL Schema
     *
     * @example Country
     */
    type?: string;
    /**
     * @description Array of fields under current type
     *
     * @example [
     *   "code",
     *   "name"
     * ]
     */
    fieldList?: string[];
  };
  /** API Deployments ClusterInfo object */
  APIDeploymentClusterInfo: {
    /**
     * @description Name of the cluster
     *
     * @example minikube
     */
    clusterName: string;
    /**
     * @description Display name of the cluster
     *
     * @example Minikube Cluster
     */
    clusterDisplayName?: string;
    /**
     * @description ingress URL
     * @example http://wso2.com:9443
     */
    ingressURL: string;
  };
  /** Current and new passowrd of the user */
  CurrentAndNewPasswords: {
    /** @example password123 */
    currentPassword?: string;
    /** @example newpassword1234 */
    newPassword?: string;
  };
}

export interface parameters {
  /**
   * @description For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
   * retrieved from.
   */
  requestedTenant: string;
  /** @description **API ID** consisting of the **UUID** of the API. */
  apiId: string;
  /** @description **API Product ID** consisting of the **UUID** of the API Product. */
  apiProductId: string;
  /** @description **API ID** consisting of the **UUID** of the API. */
  'apiId-Q': string;
  /** @description **API TYPE** Identifies the type API(API or API_PRODUCT). */
  'apiType-Q': string;
  /** @description Programming language to generate SDK. */
  language: string;
  /** @description Document Identifier */
  documentId: string;
  /** @description Application Identifier consisting of the UUID of the Application. */
  applicationId: string;
  /** @description OAuth Key Identifier consisting of the UUID of the Oauth Key Mapping. */
  keyMappingId: string;
  /** @description Filter user by roles. */
  filterByUserRoles: boolean;
  /** @description **Application Identifier** consisting of the UUID of the Application. */
  'applicationId-Q': string;
  /** @description Application Group Id */
  groupId: string;
  /** @description Subscription Id */
  subscriptionId: string;
  /** @description The name of the policy */
  policyId: string;
  /** @description Comment Id */
  commentId: string;
  /** @description Rating Id */
  ratingId: string;
  /**
   * @description List Application or Subscription type thro.
   *
   * @enum {string}
   */
  policyLevel: 'application' | 'subscription';
  /** @description Name of the API microgateway labels */
  labelName: string;
  /** @description Name of the API gateway environment. */
  environmentName: string;
  /** @description Name of the container managed cluster name. */
  clusterName: string;
  /**
   * @description Maximum size of resource array to return.
   *
   * @default 25
   */
  limit: number;
  /**
   * @description Starting point within the complete list of items qualified.
   *
   * @default 0
   */
  offset: number;
  /**
   * @description **Application Key Type** standing for the type of the keys (i.e. Production or Sandbox).
   *
   * @enum {string}
   */
  keyType: 'PRODUCTION' | 'SANDBOX';
  /**
   * @description Validator for conditional requests; based on the ETag of the formerly retrieved
   * variant of the resourec.
   */
  'If-None-Match': string;
  /** @description Validator for conditional requests; based on ETag. */
  'If-Match': string;
  /** @description The alert type. */
  alertType: string;
  /**
   * @description The alert configuration id.
   * Base64 encoded value of 'apiName#apiVersion#applicationName'.
   */
  configurationId: string;
}

export interface responses {
  /** Bad Request. Invalid request or validation error. */
  BadRequest: {
    schema: definitions['Error'];
  };
  /** Unauthorized. The user is not authorized. */
  Unauthorized: {
    schema: definitions['Error'];
  };
  /** Not Found. The specified resource does not exist. */
  NotFound: {
    schema: definitions['Error'];
  };
  /** Not Acceptable. The requested media type is not supported. */
  NotAcceptable: {
    schema: definitions['Error'];
  };
  /** Conflict. Specified resource already exists. */
  Conflict: {
    schema: definitions['Error'];
  };
  /** Precondition Failed. The request has not been performed because one of the preconditions is not met. */
  PreconditionFailed: {
    schema: definitions['Error'];
  };
  /** Unsupported Media Type. The entity of the request was not in a supported format. */
  UnsupportedMediaType: {
    schema: definitions['Error'];
  };
  /** Internal Server Error. */
  InternalServerError: {
    schema: definitions['Error'];
  };
}

export interface operations {
  /** This operation can be used to retrieve the swagger definition of an API. */
  getWSDLOfAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters['apiId'];
      };
      query: {
        /** Name of the API microgateway labels */
        labelName?: parameters['labelName'];
        /** Name of the API gateway environment. */
        environmentName?: parameters['environmentName'];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resourec.
         */
        'If-None-Match'?: parameters['If-None-Match'];
        /**
         * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
         * retrieved from.
         */
        'X-WSO2-Tenant'?: parameters['requestedTenant'];
      };
    };
    responses: {
      /**
       * OK.
       * Requested WSDL document of the API is returned
       */
      200: unknown;
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses['NotFound'];
      406: responses['NotAcceptable'];
    };
  };
  /** Get a list of Comments that are already added to APIs */
  getAllCommentsOfAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters['apiId'];
      };
      header: {
        /**
         * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
         * retrieved from.
         */
        'X-WSO2-Tenant'?: parameters['requestedTenant'];
      };
      query: {
        /** Maximum size of resource array to return. */
        limit?: parameters['limit'];
        /** Starting point within the complete list of items qualified. */
        offset?: parameters['offset'];
      };
    };
    responses: {
      /**
       * OK.
       * Comments list is returned.
       */
      200: {
        schema: definitions['CommentList'];
      };
      401: responses['Unauthorized'];
      406: responses['NotAcceptable'];
    };
  };
  addCommentToAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters['apiId'];
      };
      body: {
        /** Comment object that should to be added */
        body: definitions['Comment'];
      };
    };
    responses: {
      /**
       * Created.
       * Successful response with the newly created object as entity in the body.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {};
        schema: definitions['Comment'];
      };
      400: responses['BadRequest'];
      401: responses['Unauthorized'];
      415: responses['UnsupportedMediaType'];
    };
  };
  /** Get the individual comment given by a username for a certain API. */
  getCommentOfAPI: {
    parameters: {
      path: {
        /** Comment Id */
        commentId: parameters['commentId'];
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters['apiId'];
      };
      header: {
        /**
         * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
         * retrieved from.
         */
        'X-WSO2-Tenant'?: parameters['requestedTenant'];
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resourec.
         */
        'If-None-Match'?: parameters['If-None-Match'];
      };
    };
    responses: {
      /**
       * OK.
       * Comment returned.
       */
      200: {
        headers: {};
        schema: definitions['Comment'];
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource.
       */
      304: never;
      401: responses['Unauthorized'];
      404: responses['NotFound'];
      406: responses['NotAcceptable'];
    };
  };
  /** Remove a Comment */
  deleteComment: {
    parameters: {
      path: {
        /** Comment Id */
        commentId: parameters['commentId'];
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters['apiId'];
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        'If-Match'?: parameters['If-Match'];
      };
    };
    responses: {
      /**
       * OK.
       * Resource successfully deleted.
       */
      200: unknown;
      401: responses['Unauthorized'];
      404: responses['NotFound'];
    };
  };
  /** This operation is used to get the list of supportd alert types for the 'subscriber' agent. */
  getStoreAlertTypes: {
    responses: {
      /**
       * OK.
       * The list of subscriber alert types are returned.
       */
      200: {
        headers: {};
        schema: definitions['AlertTypesList'];
      };
      500: responses['InternalServerError'];
    };
  };
  /** This operation is used to get the list of subscribed alert types by the user. */
  getSubscribedAlertTypes: {
    responses: {
      /**
       * OK.
       * The list of subscribed alert types are returned.
       */
      200: {
        headers: {};
        schema: definitions['AlertsInfo'];
      };
      500: responses['InternalServerError'];
    };
  };
  /** This operation is used to susbscribe to the selected alert types by the user. */
  subscribeToAlerts: {
    parameters: {
      body: {
        /** The alerts list and the email list to subscribe. */
        body: definitions['AlertsInfo'];
      };
    };
    responses: {
      /**
       * OK.
       * Successful response with the newly subscribed alerts.
       */
      201: {
        headers: {};
        schema: definitions['AlertsInfoResponse'];
      };
      /**
       * Bad Request.
       * Invalid Request or request validation failure.
       */
      400: unknown;
      500: responses['InternalServerError'];
    };
  };
  /** This operation is used to unsubscribe the respective user from all the alert types. */
  unsubscribeAllAlerts: {
    responses: {
      /**
       * OK.
       * The user is unsubscribed from the alerts successfully.
       */
      200: unknown;
      500: responses['InternalServerError'];
    };
  };
  /** This operation is used to get all configurations of the AbnormalRequestsPerMin alert type. */
  getAllAlertConfigs: {
    parameters: {
      path: {
        /** The alert type. */
        alertType: parameters['alertType'];
      };
    };
    responses: {
      /**
       * OK.
       * The store alert configuration.
       */
      200: {
        headers: {};
        schema: definitions['AlertConfigList'];
      };
      500: responses['InternalServerError'];
    };
  };
  /** This operation is used to add configuration for the AbnormalRequestsPerMin alert type. */
  addAlertConfig: {
    parameters: {
      path: {
        /** The alert type. */
        alertType: parameters['alertType'];
        /**
         * The alert configuration id.
         * Base64 encoded value of 'apiName#apiVersion#applicationName'.
         */
        configurationId: parameters['configurationId'];
      };
      body: {
        /** Configuration for AbnormalRequestCount alert type */
        body: definitions['AlertConfigInfo'];
      };
    };
    responses: {
      /**
       * Created.
       * Successful response with newly created object as entity.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {};
        schema: definitions['AlertConfig'];
      };
      400: responses['BadRequest'];
      500: responses['InternalServerError'];
    };
  };
  /** This operation is used to delete configuration from the AbnormalRequestsPerMin alert type. */
  deleteAlertConfig: {
    parameters: {
      path: {
        /** The alert type. */
        alertType: parameters['alertType'];
        /**
         * The alert configuration id.
         * Base64 encoded value of 'apiName#apiVersion#applicationName'.
         */
        configurationId: parameters['configurationId'];
      };
    };
    responses: {
      /**
       * OK.
       * The alert config is deleted successfully.
       */
      200: unknown;
      400: responses['BadRequest'];
      404: responses['NotFound'];
      500: responses['InternalServerError'];
    };
  };
  /** Using this operation, logged-in user can change their password. */
  changeUserPassword: {
    parameters: {
      body: {
        /** Current and new password of the user */
        body: definitions['CurrentAndNewPasswords'];
      };
    };
    responses: {
      /** OK. User password changed successfully */
      200: unknown;
      400: responses['BadRequest'];
    };
  };
}

export interface external {}
