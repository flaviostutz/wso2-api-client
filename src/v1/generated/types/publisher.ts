/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/apis": {
    /**
     * This operation provides you a list of available APIs qualifying under a given search condition.
     *
     * Each retrieved API is represented with a minimal amount of attributes. If you want to get complete details of an API, you need to use **Get details of an API** operation.
     */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
          /**
           * **Search condition**.
           *
           * You can search in attributes by using an **"<attribute>:"** modifier.
           *
           * Eg.
           * "provider:wso2" will match an API if the provider of the API contains "wso2".
           * "provider:"wso2"" will match an API if the provider of the API is exactly "wso2".
           * "status:PUBLISHED" will match an API if the API is in PUBLISHED state.
           * "label:external" will match an API if it contains a Microgateway label called "external".
           *
           * Also you can use combined modifiers
           * Eg.
           * name:pizzashack version:v1 will match an API if the name of the API is pizzashack and version is v1.
           *
           * Supported attribute modifiers are [**version, context, name, status,
           * description, subcontext, doc, provider, label**]
           *
           * If no advanced attribute modifier has been specified,  the API names containing
           * the search term will be returned as a result.
           *
           * Please note that you need to use encoded URL (URL encoding) if you are using a client which does not support URL encoding (such as curl)
           */
          query?: string;
          /** Defines whether the returned response should contain full details of API */
          expand?: parameters["expand"];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           *   retirieved from.
           */
          "X-WSO2-Tenant"?: parameters["requestedTenant"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
        };
      };
      responses: {
        /**
         * OK.
         * List of qualifying APIs is returned.
         */
        200: {
          headers: {};
          schema: definitions["APIList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        406: responses["NotAcceptable"];
      };
    };
    /**
     * This operation can be used to create a new API specifying the details of the API in the payload. The new API will be in `CREATED` state.
     *
     * There is a special capability for a user who has `APIM Admin` permission such that he can create APIs on behalf of other users. For that he can to specify `"provider" : "some_other_user"` in the payload so that the API's creator will be shown as `some_other_user` in the UI.
     */
    post: {
      parameters: {
        body: {
          /** API object that needs to be added */
          body: definitions["API"];
        };
        query: {
          /** Open api version */
          openAPIVersion?: "V2" | "V3";
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created object as entity in the body.
         * Location header contains URL of newly created entity.
         */
        201: {
          headers: {};
          schema: definitions["API"];
        };
        400: responses["BadRequest"];
        415: responses["UnsupportedMediaType"];
      };
    };
  };
  "/apis/{apiId}": {
    /** Using this operation, you can retrieve complete details of a single API. You need to provide the Id of the API to retrive it. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           *   retirieved from.
           */
          "X-WSO2-Tenant"?: parameters["requestedTenant"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested API is returned
         */
        200: {
          headers: {};
          schema: definitions["API"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /**
     * This operation can be used to update an existing API.
     * But the properties `name`, `version`, `context`, `provider`, `state` will not be changed by this operation.
     */
    put: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        body: {
          /** API object that needs to be added */
          body: definitions["API"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Successful response with updated API object
         */
        200: {
          headers: {};
          schema: definitions["API"];
        };
        400: responses["BadRequest"];
        403: responses["Forbidden"];
        404: responses["NotFound"];
        409: responses["Conflict"];
        412: responses["PreconditionFailed"];
      };
    };
    /** This operation can be used to delete an existing API proving the Id of the API. */
    delete: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Resource successfully deleted.
         */
        200: unknown;
        403: responses["Forbidden"];
        404: responses["NotFound"];
        409: responses["Conflict"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/swagger": {
    /** This operation can be used to retrieve the swagger definition of an API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested swagger document of the API is returned
         */
        200: {
          headers: {};
          schema: string;
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to update the swagger definition of an existing API. Swagger definition to be updated is passed as a form data parameter `apiDefinition`. */
    put: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        formData: {
          /** Swagger definition of the API */
          apiDefinition?: string;
          /** Swagger definition URL of the API */
          url?: string;
          /** Swagger definitio as a file */
          file?: unknown;
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Successful response with updated Swagger definition
         */
        200: {
          headers: {};
          schema: string;
        };
        400: responses["BadRequest"];
        403: responses["Forbidden"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/generate-mock-scripts": {
    /** This operation can be used to generate mock responses from examples of swagger definition of an API. */
    post: operations["generateMockScripts"];
  };
  "/apis/{apiId}/generated-mock-scripts": {
    /** This operation can be used to get generated mock responses from examples of swagger definition of an API. */
    get: operations["getGeneratedMockScriptsOfAPI"];
  };
  "/apis/{apiId}/resource-policies": {
    /** This operation can be used to retrieve conversion policy resource definitions of an API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        query: {
          /** Resource path of the resource policy definition */
          resourcePath?: string;
          /** HTTP verb of the resource path of the resource policy definition */
          verb?: string;
          /** sequence type of the resource policy resource definition */
          sequenceType: string;
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * List of resource policy definitions of the API is returned
         */
        200: {
          headers: {};
          schema: definitions["ResourcePolicyList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
  };
  "/apis/{apiId}/resource-policies/{resourcePolicyId}": {
    /** This operation can be used to retrieve conversion policy resource definitions of an API given the resource identifier. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
          /** registry resource Id */
          resourcePolicyId: parameters["resourcePolicyId"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested resource policy definition of the API is returned for the given resource identifier.
         */
        200: {
          headers: {};
          schema: definitions["ResourcePolicyInfo"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to update the resource policy(inflow/outflow) definition for the given resource identifier of an existing API. resource policy definition to be updated is passed as a body parameter `content`. */
    put: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
          /** registry resource Id */
          resourcePolicyId: parameters["resourcePolicyId"];
        };
        body: {
          /** Content of the resource policy definition that needs to be updated */
          body: definitions["ResourcePolicyInfo"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Successful response with updated the resource policy definition
         */
        200: {
          headers: {};
          schema: definitions["ResourcePolicyInfo"];
        };
        400: responses["BadRequest"];
        403: responses["Forbidden"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/thumbnail": {
    /** This operation can be used to download a thumbnail image of an API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Thumbnail image returned
         */
        200: unknown;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to upload a thumbnail image of an API. The thumbnail to be uploaded should be given as a form data parameter `file`. */
    put: operations["updateAPIThumbnail"];
  };
  "/apis/{apiId}/subscription-policies": {
    /**
     * This operation can be used to retrieve details of the subscription throttling policy of an API by specifying the API Id.
     *
     * `X-WSO2-Tenant` header can be used to retrive API subscription throttling policies that belongs to a different tenant domain. If not specified super tenant will be used. If Authorization header is present in the request, the user's tenant associated with the access token will be used.
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /**
           * For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
           *   retirieved from.
           */
          "X-WSO2-Tenant"?: parameters["requestedTenant"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Throttling Policy returned
         */
        200: {
          headers: {};
          schema: definitions["ThrottlingPolicy"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource.
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
  };
  "/apis/copy-api": {
    /** This operation can be used to create a new version of an existing API. The new version is specified as `newVersion` query parameter. New API will be in `CREATED` state. */
    post: {
      parameters: {
        query: {
          /** Version of the new API. */
          newVersion: string;
          /** Specifies whether new API should be added as default version. */
          defaultVersion?: boolean;
          /**
           * **API ID** consisting of the **UUID** of the API.
           * The combination of the provider of the API, name of the API and the version is also accepted as a valid API I.
           * Should be formatted as **provider-name-version**.
           */
          apiId: parameters["apiId-Q"];
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created API as entity in the body. Location header contains URL of newly created API.
         */
        201: {
          headers: {};
          schema: definitions["API"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
      };
    };
  };
  "/apis/change-lifecycle": {
    /**
     * This operation is used to change the lifecycle of an API. Eg: Publish an API which is in `CREATED` state. In order to change the lifecycle, we need to provide the lifecycle `action` as a query parameter.
     *
     * For example, to Publish an API, `action` should be `Publish`. Note that the `Re-publish` action is available only after calling `Block`.
     *
     * Some actions supports providing additional paramters which should be provided as `lifecycleChecklist` parameter. Please see parameters table for more information.
     */
    post: {
      parameters: {
        query: {
          /**
           * The action to demote or promote the state of the API.
           *
           * Supported actions are [ **Publish**, **Deploy as a Prototype**, **Demote to Created**, **Block**, **Deprecate**, **Re-Publish**, **Retire** ]
           */
          action:
            | "Publish"
            | "Deploy as a Prototype"
            | "Demote to Created"
            | "Block"
            | "Deprecate"
            | "Re-Publish"
            | "Retire";
          /**
           * Supported checklist items are as follows.
           * 1. **Deprecate old versions after publishing the API**: Setting this to true will deprecate older versions of a particular API when it is promoted to Published state from Created state.
           * 2. **Requires re-subscription when publishing the API**: If you set this to true, users need to re subscribe to the API although they may have subscribed to an older version.
           * You can specify additional checklist items by using an **"attribute:"** modifier.
           * Eg: "Deprecate old versions after publishing the API:true" will deprecate older versions of a particular API when it is promoted to Published state from Created state. Multiple checklist items can be given in "attribute1:true, attribute2:false" format.
           * **Sample CURL :**  curl -k -H "Authorization: Bearer ae4eae22-3f65-387b-a171-d37eaa366fa8" -X POST "https://localhost:9443/api/am/publisher/v1/apis/change-lifecycle?apiId=890a4f4d-09eb-4877-a323-57f6ce2ed79b&action=Publish&lifecycleChecklist=Deprecate%20old%20versions%20after%20publishing%20the%20API%3Atrue,Requires%20re-subscription%20when%20publishing%20the%20API%3Afalse"
           */
          lifecycleChecklist?: string;
          /**
           * **API ID** consisting of the **UUID** of the API.
           * The combination of the provider of the API, name of the API and the version is also accepted as a valid API I.
           * Should be formatted as **provider-name-version**.
           */
          apiId: parameters["apiId-Q"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Lifecycle changed successfully.
         */
        200: {
          headers: {};
          schema: definitions["WorkflowResponse"];
        };
        /**
         * Accepted.
         * The request has been accepted.
         */
        202: {
          schema: definitions["WorkflowResponse"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        409: responses["Conflict"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/lifecycle-history": {
    /** This operation can be used to retrieve Lifecycle state change history of the API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Lifecycle state change history returned successfully.
         */
        200: {
          headers: {};
          schema: definitions["LifecycleHistory"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
      };
    };
  };
  "/apis/{apiId}/lifecycle-state": {
    /** This operation can be used to retrieve Lifecycle state data of the API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Lifecycle state data returned successfully.
         */
        200: {
          headers: {};
          schema: definitions["LifecycleState"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/lifecycle-state/pending-tasks": {
    /** This operation can be used to remove pending lifecycle state change requests that are in pending state */
    delete: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
      };
      responses: {
        /**
         * OK.
         * Lifecycle state change pending task removed successfully.
         */
        200: unknown;
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/import-openapi": {
    /**
     * This operation can be used to create an API from an OpenAPI definition. Provide either `url` or `file`
     * to specify the definition.
     *
     * Specify additionalProperties with **at least** API's name, version, context and endpointConfig.
     */
    post: operations["importOpenAPIDefinition"];
  };
  "/apis/import-wsdl": {
    /**
     * This operation can be used to create an API using a WSDL definition. Provide either `url` or `file`
     * to specify the definition.
     *
     * WSDL can be speficied as a single file or a ZIP archive with WSDLs and reference XSDs etc.
     * Specify additionalProperties with **at least** API's name, version, context and endpointConfig.
     */
    post: operations["importWSDLDefinition"];
  };
  "/apis/import-graphql-schema": {
    /**
     * This operation can be used to create api from api definition.APIMgtDAOTest
     *
     * API definition is GraphQL Schema
     */
    post: {
      parameters: {
        formData: {
          /** Definition type to upload */
          type?: string;
          /** Definition to uploads a file */
          file?: unknown;
          /** Additional attributes specified as a stringified JSON with API's schema */
          additionalProperties?: string;
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created object as entity in the body.
         * Location header contains URL of newly created entity.
         */
        201: {
          headers: {};
          schema: definitions["API"];
        };
        400: responses["BadRequest"];
        415: responses["UnsupportedMediaType"];
      };
    };
  };
  "/apis/validate-openapi": {
    /**
     * This operation can be used to validate an OpenAPI definition and retrieve a summary. Provide either `url`
     * or `file` to specify the definition.
     */
    post: operations["validateOpenAPIDefinition"];
  };
  "/apis/validate-endpoint": {
    /** Using this operation, it is possible check whether the given API endpoint url is a valid url */
    post: operations["validateEndpoint"];
  };
  "/apis/validate": {
    /** Using this operation, you can check a given API context is already used. You need to provide the context name you want to check. */
    post: operations["validateAPI"];
  };
  "/apis/validate-wsdl": {
    /**
     * This operation can be used to validate a WSDL definition and retrieve a summary. Provide either `url`
     * or `file` to specify the definition.
     */
    post: operations["validateWSDLDefinition"];
  };
  "/apis/validate-graphql-schema": {
    /** This operation can be used to validate a graphQL definition and retrieve a summary. */
    post: {
      parameters: {
        formData: {
          /** Definition to upload as a file */
          file: unknown;
        };
      };
      responses: {
        /**
         * OK.
         * API definition validation information is returned
         */
        200: {
          headers: {};
          schema: definitions["GraphQLValidationResponse"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
      };
    };
  };
  "/apis/{apiId}/graphql-schema": {
    /** This operation can be used to retrieve the Schema definition of a GraphQL API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested GraphQL Schema DTO object belongs to the API
         */
        200: {
          headers: {};
          schema: definitions["GraphQLSchema"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to add a GraphQL Schema definition to an existing GraphQL API. */
    put: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        formData: {
          /** schema definition of the GraphQL API */
          schemaDefinition: string;
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Successful response with updated schema definition
         */
        200: unknown;
        400: responses["BadRequest"];
        403: responses["Forbidden"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/amznResourceNames": {
    /** This operation can be use to retrieve ARNs of AWS Lambda function for a given AWS credentials. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested ARN List of the API is returned
         */
        200: {
          headers: {};
          schema: string;
        };
        404: responses["NotFound"];
      };
    };
  };
  "/apis/{apiId}/monetize": {
    /** This operation can be used to configure monetization for a given API. */
    post: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        body: {
          /** Monetization data object */
          body: definitions["APIMonetizationInfo"];
        };
      };
      responses: {
        /**
         * OK.
         * Monetization status changed successfully.
         */
        201: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
  };
  "/apis/{apiId}/monetization": {
    /** This operation can be used to get monetization status for each tier in a given API */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
      };
      responses: {
        /**
         * OK.
         * Monetization status for each tier returned successfully.
         */
        200: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
  };
  "/apis/{apiId}/revenue": {
    /** This operation can be used to get details of total revenue details of a given monetized API with meterd billing. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
      };
      responses: {
        /**
         * OK.
         * Details of a total revenue returned.
         */
        200: {
          headers: {};
          schema: definitions["APIRevenue"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
      };
    };
  };
  "/apis/{apiId}/documents": {
    /** This operation can be used to retrieve a list of documents belonging to an API by providing the id of the API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document list is returned.
         */
        200: {
          headers: {};
          schema: definitions["DocumentList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to add a new documentation to an API. This operation only adds the metadata of a document. To add the actual content we need to use **Upload the content of an API document ** API once we obtain a document Id by this operation. */
    post: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        body: {
          /** Document object that needs to be added */
          body: definitions["Document"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created Document object as entity in the body.
         * Location header contains URL of newly added document.
         */
        201: {
          headers: {};
          schema: definitions["Document"];
        };
        400: responses["BadRequest"];
        415: responses["UnsupportedMediaType"];
      };
    };
  };
  "/apis/{apiId}/documents/{documentId}": {
    /** This operation can be used to retrieve a particular document's metadata associated with an API. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document returned.
         */
        200: {
          headers: {};
          schema: definitions["Document"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to update metadata of an API's document. */
    put: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        body: {
          /** Document object that needs to be added */
          body: definitions["Document"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document updated
         */
        200: {
          headers: {};
          schema: definitions["Document"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
    /** This operation can be used to delete a document associated with an API. */
    delete: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Resource successfully deleted.
         */
        200: unknown;
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/documents/{documentId}/content": {
    /**
     * This operation can be used to retrive the content of an API's document.
     *
     * The document can be of 3 types. In each cases responses are different.
     *
     * 1. **Inline type**:
     *    The content of the document will be retrieved in `text/plain` content type
     *
     *    _Sample cURL_ : `curl -k -H "Authorization:Bearer 579f0af4-37be-35c7-81a4-f1f1e9ee7c51" -F inlineContent=@"docs.txt" -X POST "https://localhost:9443/api/am/publisher/v1/apis/995a4972-3178-4b17-a374-756e0e19127c/documents/43c2bcce-60e7-405f-bc36-e39c0c5e189e/content`
     * 2. **FILE type**:
     *    The file will be downloaded with the related content type (eg. `application/pdf`)
     * 3. **URL type**:
     *     The client will recieve the URL of the document as the Location header with the response with - `303 See Other`
     */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * File or inline content returned.
         */
        200: unknown;
        /**
         * See Other.
         * Source can be retrived from the URL specified at the Location header.
         */
        303: never;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /**
     * Thid operation can be used to upload a file or add inline content to an API document.
     *
     * **IMPORTANT:**
     * * Either **file** or **inlineContent** form data parameters should be specified at one time.
     * * Document's source type should be **FILE** in order to upload a file to the document using **file** parameter.
     * * Document's source type should be **INLINE** in order to add inline content to the document using **inlineContent** parameter.
     */
    post: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        formData: {
          /** Document to upload */
          file?: unknown;
          /** Inline content of the document */
          inlineContent?: string;
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document updated
         */
        200: {
          headers: {};
          schema: definitions["Document"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/apis/{apiId}/documents/validate": {
    /** This operation can be used to verify the document name exists or not. */
    post: operations["validateDocument"];
  };
  "/apis/{apiId}/mediation-policies": {
    /** This operation provides you a list of available mediation policies of an API. */
    get: operations["apisApiIdMediationPoliciesGet"];
    /** This operation can be used to add an API specifc mediation policy. */
    post: operations["apisApiIdMediationPoliciesPost"];
  };
  "/apis/{apiId}/mediation-policies/{mediationPolicyId}": {
    /** This operation can be used to retrieve a particular API specific mediation policy. */
    get: operations["apisApiIdMediationPoliciesMediationPolicyIdGet"];
    /** This operation can be used to delete an existing API specific mediation policy providing the Id of the API and the Id of the mediation policy. */
    delete: operations["apisApiIdMediationPoliciesMediationPolicyIdDelete"];
  };
  "/apis/{apiId}/mediation-policies/{mediationPolicyId}/content": {
    /** This operation can be used to download a particular API specific mediation policy. */
    get: operations["apisApiIdMediationPoliciesMediationPolicyIdContentGet"];
    /** This operation can be used to update an existing mediation policy of an API. */
    put: operations["apisApiIdMediationPoliciesMediationPolicyIdContentPut"];
  };
  "/apis/{apiId}/wsdl-info": {
    /**
     * This operation can be used to retrieve the WSDL meta information of an API. It states whether the API is a SOAP
     * API. If the API is a SOAP API, it states whether it has a single WSDL or a WSDL archive.
     */
    get: operations["getWSDLInfoOfAPI"];
  };
  "/apis/{apiId}/wsdl": {
    /**
     * This operation can be used to retrieve the WSDL definition of an API. It can be either a single WSDL file or a WSDL archive.
     *
     * The type of the WSDL of the API is indicated at the "wsdlInfo" element of the API payload definition.
     */
    get: operations["getWSDLOfAPI"];
    /**
     * This operation can be used to update the WSDL definition of an existing API. WSDL to be updated can be passed as either "url" or "file".
     * Only one of "url" or "file" can be used at the same time. "file" can be specified as a single WSDL file or as a zip file which has a WSDL
     * and its dependencies (eg: XSDs)
     */
    put: operations["updateWSDLOfAPI"];
  };
  "/apis/{apiId}/graphql-policies/complexity": {
    /** This operation can be used to retrieve complexity related details belonging to an API by providing the API id. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested complexity details returned.
         */
        200: unknown;
        404: responses["NotFound"];
      };
    };
    /** This operation can be used to update complexity details belonging to an API by providing the id of the API. */
    put: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        body: {
          /** Role-depth mapping that needs to be added */
          body: definitions["GraphQLQueryComplexityInfo"];
        };
      };
      responses: {
        /**
         * Created.
         * Complexity details created successfully.
         */
        200: unknown;
        404: responses["NotFound"];
      };
    };
  };
  "/apis/{apiId}/graphql-policies/complexity/types": {
    /** This operation can be used to retrieve all types and fields of the GraphQL Schema by providing the API id. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
      };
      responses: {
        /**
         * OK.
         * Types and fields returned successfully.
         */
        200: {
          headers: {};
          schema: definitions["GraphQLSchemaTypeList"];
        };
        404: responses["NotFound"];
      };
    };
  };
  "/apis/{apiId}/resource-paths": {
    /** This operation can be used to retrieve resource paths defined for a specific api. */
    get: {
      parameters: {
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * ResourcePaths returned.
         */
        200: {
          headers: {};
          schema: definitions["ResourcePathList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
  };
  "/apis/{apiId}/auditapi": {
    /** Retrieve the Security Audit Report of the Audit API */
    get: {
      parameters: {
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
        };
        path: {
          /** **API ID** consisting of the **UUID** of the API. */
          apiId: parameters["apiId"];
        };
      };
      responses: {
        /**
         * OK.
         * The Security Audit Report has been returned.
         */
        200: {
          headers: {};
          schema: definitions["AuditReport"];
        };
        404: responses["NotFound"];
      };
    };
  };
  "/apis/{apiId}/external-stores": {
    /** This operation can be used to retrieve a list of external stores which an API is published to by providing the id of the API. */
    get: operations["getAllPublishedExternalStoresByAPI"];
  };
  "/apis/{apiId}/publish-to-external-stores": {
    /** This operation can be used to publish an API to a list of external stores. */
    post: operations["publishAPIToExternalStores"];
  };
  "/apis/export": {
    /** This operation can be used to export the details of a particular API as a zip file. */
    get: {
      parameters: {
        query: {
          /** UUID of the API */
          apiId?: string;
          /** API Name */
          name?: string;
          /** Version of the API */
          version?: string;
          /** Provider name of the API */
          providerName?: string;
          /** Format of output documents. Can be YAML or JSON. */
          format?: "JSON" | "YAML";
          /** Preserve API Status on export */
          preserveStatus?: boolean;
        };
      };
      responses: {
        /**
         * OK.
         * Export Successful.
         */
        200: {
          headers: {};
          schema: unknown;
        };
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
  };
  "/subscriptions": {
    /**
     * This operation can be used to retrieve a list of subscriptions of the user associated with the provided access token. This operation is capable of
     *
     * 1. Retrieving all subscriptions for the user's APIs.
     * `GET https://127.0.0.1:9443/api/am/publisher/v1/subscriptions`
     *
     * 2. Retrieving subscriptions for a specific API.
     * `GET https://127.0.0.1:9443/api/am/publisher/v1/subscriptions?apiId=c43a325c-260b-4302-81cb-768eafaa3aed`
     */
    get: {
      parameters: {
        query: {
          /**
           * **API ID** consisting of the **UUID** of the API.
           * The combination of the provider of the API, name of the API and the version is also accepted as a valid API I.
           * Should be formatted as **provider-name-version**.
           */
          apiId?: parameters["apiId-Q-Opt"];
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
          /** Keywords to filter subscriptions */
          query?: string;
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Subscription list returned.
         */
        200: {
          headers: {};
          schema: definitions["SubscriptionList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        406: responses["NotAcceptable"];
      };
    };
  };
  "/subscriptions/{subscriptionId}/usage": {
    /** This operation can be used to get details of a pending invoice for a monetized subscription with meterd billing. */
    get: {
      parameters: {
        path: {
          /** Subscription Id */
          subscriptionId: parameters["subscriptionId"];
        };
      };
      responses: {
        /**
         * OK.
         * Details of a pending invoice returned.
         */
        200: {
          headers: {};
          schema: definitions["APIMonetizationUsage"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        /**
         * Not Found.
         * Requested Subscription does not exist.
         */
        404: {
          schema: definitions["Error"];
        };
      };
    };
  };
  "/subscriptions/{subscriptionId}/subscriber-info": {
    /** This operation can be used to get details of a user who subscribed to the API. */
    get: {
      parameters: {
        path: {
          /** Subscription Id */
          subscriptionId: parameters["subscriptionId"];
        };
      };
      responses: {
        /**
         * OK.
         *  Details of the subscriber are returned.
         */
        200: {
          schema: definitions["SubscriberInfo"];
        };
        404: responses["NotFound"];
      };
    };
  };
  "/subscriptions/block-subscription": {
    /**
     * This operation can be used to block a subscription. Along with the request, `blockState` must be specified as a query parameter.
     *
     * 1. `BLOCKED` : Subscription is completely blocked for both Production and Sandbox environments.
     * 2. `PROD_ONLY_BLOCKED` : Subscription is blocked for Production environment only.
     */
    post: {
      parameters: {
        query: {
          /** Subscription Id */
          subscriptionId: parameters["subscriptionId-Q"];
          /** Subscription block state. */
          blockState: "BLOCKED" | "PROD_ONLY_BLOCKED";
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Subscription was blocked successfully.
         */
        200: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/subscriptions/unblock-subscription": {
    /** This operation can be used to unblock a subscription specifying the subscription Id. The subscription will be fully unblocked after performing this operation. */
    post: {
      parameters: {
        query: {
          /** Subscription Id */
          subscriptionId: parameters["subscriptionId-Q"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Subscription was unblocked successfully.
         */
        200: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/throttling-policies/{policyLevel}": {
    /**
     * This operation can be used to list the available policies for a given policy level. Tier level should be specified as a path parameter and should be one of `subscription` and `api`.
     * `subscription` is for Subscription Level policies and `api` is for Resource Level policies
     */
    get: operations["getAllThrottlingPolicies"];
  };
  "/throttling-policies/{policyLevel}/{policyName}": {
    /** This operation can be used to retrieve details of a single policy by specifying the policy level and policy name. */
    get: operations["getThrottlingPolicyByName"];
  };
  "/mediation-policies": {
    /** This operation provides you a list of available all global level mediation policies. */
    get: operations["getAllGlobalMediationPolicies"];
  };
  "/mediation-policies/{mediationPolicyId}/content": {
    /** This operation can be used to download a particular global mediation policy. */
    get: operations["getGlobalMediationPolicyContent"];
  };
  "/apis/{apiId}/client-certificates": {
    /** This operation can be used to retrieve and search the uploaded client certificates. */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
          /** Alias for the client certificate */
          alias?: string;
        };
        path: {
          /** UUID of the API */
          apiId: string;
        };
      };
      responses: {
        /** OK. Successful response with the list of matching certificate information in the body. */
        200: {
          headers: {};
          schema: definitions["ClientCertificates"];
        };
        400: responses["BadRequest"];
        500: responses["InternalServerError"];
      };
    };
    /** This operation can be used to upload a new certificate for an endpoint. */
    post: {
      parameters: {
        formData: {
          /** The certificate that needs to be uploaded. */
          certificate: unknown;
          /** Alias for the certificate */
          alias: string;
          /** api tier to which the certificate should be applied. */
          tier: string;
        };
        path: {
          /** apiId to which the certificate should be applied. */
          apiId: string;
        };
      };
      responses: {
        /**
         * OK.
         * The Certificate added successfully.
         */
        200: {
          headers: {};
          schema: definitions["ClientCertMetadata"];
        };
        400: responses["BadRequest"];
        500: responses["InternalServerError"];
      };
    };
  };
  "/apis/{apiId}/client-certificates/{alias}": {
    /** This operation can be used to get the information about a certificate. */
    get: {
      parameters: {
        path: {
          alias: string;
          /** The api identifier */
          apiId: string;
        };
      };
      responses: {
        /** OK. */
        200: {
          headers: {};
          schema: definitions["CertificateInfo"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
    /** This operation can be used to update an uploaded certificate. */
    put: {
      parameters: {
        formData: {
          /** The certificate that needs to be uploaded. */
          certificate?: unknown;
          /** The tier of the certificate */
          tier?: string;
        };
        path: {
          /** Alias for the certificate */
          alias: string;
          /** The api identifier */
          apiId: string;
        };
      };
      responses: {
        /**
         * OK.
         * The Certificate updated successfully.
         */
        200: {
          headers: {};
          schema: definitions["ClientCertMetadata"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
    /** This operation can be used to delete an uploaded certificate. */
    delete: {
      parameters: {
        path: {
          /** The alias of the certificate that should be deleted. */
          alias: string;
          /** The api identifier */
          apiId: string;
        };
      };
      responses: {
        /**
         * OK.
         * The Certificate deleted successfully.
         */
        200: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
  };
  "/apis/{apiId}/client-certificates/{alias}/content": {
    /** This operation can be used to download a certificate which matches the given alias. */
    get: {
      parameters: {
        path: {
          /** The api identifier */
          apiId: string;
          alias: string;
        };
      };
      responses: {
        /** OK. */
        200: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
  };
  "/endpoint-certificates": {
    /** This operation can be used to retrieve and search the uploaded certificates. */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
          /** Alias for the certificate */
          alias?: string;
          /** Endpoint of which the certificate is uploaded */
          endpoint?: string;
        };
      };
      responses: {
        /** OK. Successful response with the list of matching certificate information in the body. */
        200: {
          headers: {};
          schema: definitions["Certificates"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
    /** This operation can be used to upload a new certificate for an endpoint. */
    post: {
      parameters: {
        formData: {
          /** The certificate that needs to be uploaded. */
          certificate: unknown;
          /** Alias for the certificate */
          alias: string;
          /** Endpoint to which the certificate should be applied. */
          endpoint: string;
        };
      };
      responses: {
        /**
         * OK.
         * The Certificate added successfully.
         */
        200: {
          headers: {};
          schema: definitions["CertMetadata"];
        };
        400: responses["BadRequest"];
        500: responses["InternalServerError"];
      };
    };
  };
  "/endpoint-certificates/{alias}": {
    /** This operation can be used to get the information about a certificate. */
    get: {
      parameters: {
        path: {
          alias: string;
        };
      };
      responses: {
        /** OK. */
        200: {
          headers: {};
          schema: definitions["CertificateInfo"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
    /** This operation can be used to update an uploaded certificate. */
    put: {
      parameters: {
        formData: {
          /** The certificate that needs to be uploaded. */
          certificate: unknown;
        };
        path: {
          /** Alias for the certificate */
          alias: string;
        };
      };
      responses: {
        /**
         * OK.
         * The Certificate updated successfully.
         */
        200: {
          headers: {};
          schema: definitions["CertMetadata"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
    /** This operation can be used to delete an uploaded certificate. */
    delete: {
      parameters: {
        path: {
          /** The alias of the certificate that should be deleted. */
          alias: string;
        };
      };
      responses: {
        /**
         * OK.
         * The Certificate deleted successfully.
         */
        200: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
  };
  "/endpoint-certificates/{alias}/content": {
    /** This operation can be used to download a certificate which matches the given alias. */
    get: {
      parameters: {
        path: {
          alias: string;
        };
      };
      responses: {
        /** OK. */
        200: unknown;
        400: responses["BadRequest"];
        404: responses["NotFound"];
        500: responses["InternalServerError"];
      };
    };
  };
  "/search": {
    /** This operation provides you a list of available APIs and API Documents qualifying the given keyword match. */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
          /**
           * **Search**.
           *
           * You can search by proving a keyword.
           */
          query?: string;
        };
        header: {
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * List of qualifying APIs and API documents is returned.
         */
        200: {
          headers: {};
          schema: definitions["SearchResultList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        406: responses["NotAcceptable"];
      };
    };
  };
  "/api-products": {
    /**
     * This operation provides you a list of available API Products qualifying under a given search condition.
     *
     * Each retrieved API Product is represented with a minimal amount of attributes. If you want to get complete details of an API Product, you need to use **Get details of an API Product** operation.
     */
    get: {
      parameters: {
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
          query?: string;
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * List of qualifying API Products is returned.
         */
        200: {
          headers: {};
          schema: definitions["APIProductList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to create a new API Product specifying the details of the API Product in the payload. */
    post: {
      parameters: {
        body: {
          /** API object that needs to be added */
          body: definitions["APIProduct"];
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created object as entity in the body.
         * Location header contains URL of newly created entity.
         */
        201: {
          headers: {};
          schema: definitions["APIProduct"];
        };
        400: responses["BadRequest"];
        415: responses["UnsupportedMediaType"];
      };
    };
  };
  "/api-products/{apiProductId}": {
    /** Using this operation, you can retrieve complete details of a single API Product. You need to provide the Id of the API to retrive it. */
    get: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested API Product is returned
         */
        200: {
          headers: {};
          schema: definitions["APIProduct"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /**
     * This operation can be used to update an existing API product.
     * But the properties `name`, `provider` and `version` cannot be changed.
     */
    put: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        body: {
          /** API object that needs to be added */
          body: definitions["APIProduct"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Successful response with updated API product object
         */
        200: {
          headers: {};
          schema: definitions["APIProduct"];
        };
        400: responses["BadRequest"];
        403: responses["Forbidden"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
    /** This operation can be used to delete an existing API Product proving the Id of the API Product. */
    delete: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Resource successfully deleted.
         */
        200: unknown;
        403: responses["Forbidden"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/api-products/{apiProductId}/thumbnail": {
    /** This operation can be used to download a thumbnail image of an API product. */
    get: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Thumbnail image returned
         */
        200: unknown;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to upload a thumbnail image of an API Product. The thumbnail to be uploaded should be given as a form data parameter `file`. */
    put: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        formData: {
          /** Image to upload */
          file: unknown;
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Image updated
         */
        200: {
          headers: {};
          schema: definitions["FileInfo"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/api-products/{apiProductId}/swagger": {
    /** This operation can be used to retrieve the swagger definition of an API. */
    get: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested swagger document of the API is returned
         */
        200: unknown;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
  };
  "/api-products/{apiProductId}/is-outdated": {
    /** This operation can be used to retrieve the status indicating if an API Product is outdated due to updating of dependent APIs (This resource is not supported at the moment) */
    get: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Requested swagger document of the API is returned
         */
        200: {
          headers: {};
          schema: definitions["APIProductOutdatedStatus"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
  };
  "/api-products/{apiProductId}/documents": {
    /** This operation can be used to retrive a list of documents belonging to an API Product by providing the id of the API Product. */
    get: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        query: {
          /** Maximum size of resource array to return. */
          limit?: parameters["limit"];
          /** Starting point within the complete list of items qualified. */
          offset?: parameters["offset"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document list is returned.
         */
        200: {
          headers: {};
          schema: definitions["DocumentList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to add a new documentation to an API Product. This operation only adds the metadata of a document. To add the actual content we need to use **Upload the content of an API Product document ** API once we obtain a document Id by this operation. */
    post: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
        };
        body: {
          /** Document object that needs to be added */
          body: definitions["Document"];
        };
      };
      responses: {
        /**
         * Created.
         * Successful response with the newly created Document object as entity in the body.
         * Location header contains URL of newly added document.
         */
        201: {
          headers: {};
          schema: definitions["Document"];
        };
        400: responses["BadRequest"];
        415: responses["UnsupportedMediaType"];
      };
    };
  };
  "/api-products/{apiProductId}/documents/{documentId}": {
    /** This operation can be used to retrieve a particular document's metadata associated with an API. */
    get: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document returned.
         */
        200: {
          headers: {};
          schema: definitions["Document"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /** This operation can be used to update metadata of an API's document. */
    put: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        body: {
          /** Document object that needs to be added */
          body: definitions["Document"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document updated
         */
        200: {
          headers: {};
          schema: definitions["Document"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
    /** This operation can be used to delete a document associated with an API Product. */
    delete: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Resource successfully deleted.
         */
        200: unknown;
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/api-products/{apiProductId}/documents/{documentId}/content": {
    /**
     * This operation can be used to retrive the content of an API's document.
     *
     * The document can be of 3 types. In each cases responses are different.
     *
     * 1. **Inline type**:
     *    The content of the document will be retrieved in `text/plain` content type
     *
     *    _Sample cURL_ : `curl -k -H "Authorization:Bearer 579f0af4-37be-35c7-81a4-f1f1e9ee7c51" -F inlineContent=@"docs.txt" -X POST "https://localhost:9443/api/am/publisher/v1/apis/995a4972-3178-4b17-a374-756e0e19127c/documents/43c2bcce-60e7-405f-bc36-e39c0c5e189e/content`
     * 2. **FILE type**:
     *    The file will be downloaded with the related content type (eg. `application/pdf`)
     * 3. **URL type**:
     *     The client will recieve the URL of the document as the Location header with the response with - `303 See Other`
     */
    get: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        header: {
          /** Media types acceptable for the response. Default is application/json. */
          Accept?: parameters["Accept"];
          /**
           * Validator for conditional requests; based on the ETag of the formerly retrieved
           * variant of the resource.
           */
          "If-None-Match"?: parameters["If-None-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * File or inline content returned.
         */
        200: unknown;
        /**
         * See Other.
         * Source can be retrived from the URL specified at the Location header.
         */
        303: never;
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
        406: responses["NotAcceptable"];
      };
    };
    /**
     * Thid operation can be used to upload a file or add inline content to an API Product document.
     *
     * **IMPORTANT:**
     * * Either **file** or **inlineContent** form data parameters should be specified at one time.
     * * Document's source type should be **FILE** in order to upload a file to the document using **file** parameter.
     * * Document's source type should be **INLINE** in order to add inline content to the document using **inlineContent** parameter.
     */
    post: {
      parameters: {
        path: {
          /** **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
          apiProductId: parameters["apiProductId"];
          /** Document Identifier */
          documentId: parameters["documentId"];
        };
        formData: {
          /** Document to upload */
          file?: unknown;
          /** Inline content of the document */
          inlineContent?: string;
        };
        header: {
          /** Validator for conditional requests; based on ETag. */
          "If-Match"?: parameters["If-Match"];
        };
      };
      responses: {
        /**
         * OK.
         * Document updated
         */
        200: {
          headers: {};
          schema: definitions["Document"];
        };
        400: responses["BadRequest"];
        404: responses["NotFound"];
        412: responses["PreconditionFailed"];
      };
    };
  };
  "/roles/{roleId}": {
    /** Using this operation, user can check a given role name exists or not. */
    head: operations["validateSystemRole"];
  };
  "/me/roles/{roleId}": {
    /** Using this operation, logged-in user can check whether he has given role. */
    head: operations["validateUserRole"];
  };
  "/external-stores": {
    /** Retrieve external stores list configured to publish an API */
    get: operations["getAllExternalStores"];
  };
  "/settings": {
    /** Retreive publisher settings */
    get: {
      responses: {
        /**
         * OK.
         * Settings returned
         */
        200: {
          schema: definitions["Settings"];
        };
        404: responses["NotFound"];
      };
    };
  };
  "/settings/gateway-environments": {
    /** This operation can be used to retrieve the list of gateway environments available. */
    get: {
      parameters: {
        query: {
          /**
           * **API ID** consisting of the **UUID** of the API.
           * The combination of the provider of the API, name of the API and the version is also accepted as a valid API I.
           * Should be formatted as **provider-name-version**.
           */
          apiId: parameters["apiId-Q"];
        };
      };
      responses: {
        /**
         * OK.
         * Environment list is returned.
         */
        200: {
          headers: {};
          schema: definitions["EnvironmentList"];
        };
        /**
         * Not Modified.
         * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
         */
        304: never;
        404: responses["NotFound"];
      };
    };
  };
  "/tenants": {
    /** This operation is to get tenants by state */
    get: operations["getTenantsByState"];
  };
  "/alert-types": {
    /** This operation is used to get the list of supportd alert types for the 'publisher' agent. */
    get: operations["getPublisherAlertTypes"];
  };
  "/alert-subscriptions": {
    /** This operation is used to get the list of subscribed alert types by the user. */
    get: operations["getSubscribedAlertTypes"];
    /** This operation is used to get the list of subscribed alert types by the user. */
    put: operations["subscribeToAlerts"];
    /** This operation is used to unsubscribe the respective user from all the alert types. */
    delete: operations["unsubscribeAllAlerts"];
  };
  "/alerts/{alertType}/configurations": {
    /** This operation is used to get all configurations of the AbnormalRequestsPerMin alert type. */
    get: operations["getAllAlertConfigs"];
  };
  "/alerts/{alertType}/configurations/{configurationId}": {
    /** This operation is used to add configuration for the AbnormalRequestsPerMin alert type. */
    put: operations["addAlertConfig"];
    /** This operation is used to delete configuration from the AbnormalRequestsPerMin alert type. */
    delete: operations["deleteAlertConfig"];
  };
  "/tenants/{tenantDomain}": {
    /** Using this operation, user can check whether a given tenant exists or not. */
    head: operations["getTenantExistence"];
  };
  "/labels": {
    /** Get all registered Labels */
    get: {
      responses: {
        /**
         * OK.
         * Labels returned
         */
        200: {
          schema: definitions["LabelList"];
        };
      };
    };
  };
  "/api-categories": {
    /** Get all API categories */
    get: {
      responses: {
        /**
         * OK.
         * Categories returned
         */
        200: {
          schema: definitions["APICategoryList"];
        };
      };
    };
  };
  "/scopes": {
    /** This operation can be used to get all the available Shared Scopes. */
    get: operations["getSharedScopes"];
    /** This operation can be used to add a new Shared Scope. */
    post: operations["addSharedScope"];
  };
  "/scopes/{scopeId}": {
    /** This operation can be used to retrieve details of a Shared Scope by a given scope Id. */
    get: operations["getSharedScope"];
    /** This operation can be used to update a Shared Scope by a given scope Id. */
    put: operations["updateSharedScope"];
    /** This operation can be used to delete a Shared Scope proving the Id of the scope. */
    delete: operations["deleteSharedScope"];
    /** Using this operation, user can check a given scope name exists or not. */
    head: operations["validateScope"];
  };
  "/scopes/{scopeId}/usage": {
    /** This operation can be used to retrieve usages of a Shared Scope by a given scope Id. */
    get: operations["getSharedScopeUsages"];
  };
  "/key-managers": {
    /** Get all Key managers */
    get: {
      responses: {
        /**
         * OK.
         * Categories returned
         */
        200: {
          schema: definitions["KeyManagerList"];
        };
      };
    };
  };
  "/deployments": {
    /**
     * This operation can be used to retrieve cloud clusters information defines in tenant-conf.json file.
     *
     * With that you can deploy an API to selected cloud environments.
     */
    get: operations["deploymentsGet"];
  };
  "/apis/{apiId}/deployments": {
    /**
     * This operation can be used to retrieve the status of deployments in cloud clusters.
     *
     * With that you can get the status of the deployed APIs in cloud environments.
     */
    get: operations["deploymentsGetStatus"];
  };
}

export interface definitions {
  /** API List */
  APIList: {
    /**
     * @description Number of APIs returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["APIInfo"][];
    pagination?: definitions["Pagination"];
  };
  /** API List */
  APIListExpanded: {
    /**
     * @description Number of APIs returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["API"][];
    pagination?: definitions["Pagination"];
  };
  /** API Info object with basic API details. */
  APIInfo: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example CalculatorAPI */
    name?: string;
    /** @example A calculator API that supports basic operations */
    description?: string;
    /** @example CalculatorAPI */
    context?: string;
    /** @example 1.0.0 */
    version?: string;
    /**
     * @description If the provider value is not given, the user invoking the API will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /** @example HTTP */
    type?: string;
    /** @example CREATED */
    lifeCycleStatus?: string;
    /** @example APPROVED */
    workflowStatus?: string;
    /** @example true */
    hasThumbnail?: boolean;
    securityScheme?: string[];
  };
  /** API object */
  API: {
    /**
     * @description UUID of the api registry artifact
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id?: string;
    /** @example PizzaShackAPI */
    name: string;
    /** @example This is a simple API for Pizza Shack online pizza delivery store. */
    description?: string;
    /** @example pizza */
    context: string;
    /** @example 1.0.0 */
    version: string;
    /**
     * @description If the provider value is not given user invoking the api will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /** @example CREATED */
    lifeCycleStatus?: string;
    wsdlInfo?: definitions["WSDLInfo"];
    /** @example /apimgt/applicationdata/wsdls/admin--soap1.wsdl */
    wsdlUrl?: string;
    /** @example 8swdwj9080edejhj */
    testKey?: string;
    /** @example true */
    responseCachingEnabled?: boolean;
    /** @example 300 */
    cacheTimeout?: number;
    /** @example Disabled */
    destinationStatsEnabled?: string;
    /** @example false */
    hasThumbnail?: boolean;
    /** @example false */
    isDefaultVersion?: boolean;
    /** @example false */
    enableSchemaValidation?: boolean;
    /** @example true */
    enableStore?: boolean;
    /**
     * @description The api creation type to be used. Accepted values are HTTP, WS, SOAPTOREST, GRAPHQL
     * @default HTTP
     * @example HTTP
     * @enum {string}
     */
    type?: "HTTP" | "WS" | "SOAPTOREST" | "SOAP" | "GRAPHQL";
    /**
     * @description Supported transports for the API (http and/or https).
     *
     * @example [
     *   "http",
     *   "https"
     * ]
     */
    transport?: string[];
    /**
     * @example [
     *   "pizza",
     *   "food"
     * ]
     */
    tags?: string[];
    /**
     * @example [
     *   "Unlimited"
     * ]
     */
    policies?: string[];
    /**
     * @description The API level throttling policy selected for the particular API
     * @example Unlimited
     */
    apiThrottlingPolicy?: string;
    /**
     * @description Name of the Authorization header used for invoking the API. If it is not set, Authorization header name specified
     * in tenant or system level will be used.
     *
     * @example Authorization
     */
    authorizationHeader?: string;
    /**
     * @description Types of API security, the current API secured with. It can be either OAuth2 or mutual SSL or both. If
     * it is not set OAuth2 will be set as the security for the current API.
     *
     * @example [
     *   "oauth2"
     * ]
     */
    securityScheme?: string[];
    maxTps?: definitions["APIMaxTps"];
    /**
     * @description The visibility level of the API. Accepts one of the following. PUBLIC, PRIVATE, RESTRICTED.
     * @default PUBLIC
     * @example PUBLIC
     * @enum {string}
     */
    visibility?: "PUBLIC" | "PRIVATE" | "RESTRICTED";
    /**
     * @description The user roles that are able to access the API in Store
     * @example []
     */
    visibleRoles?: string[];
    /** @example [] */
    visibleTenants?: string[];
    endpointSecurity?: definitions["APIEndpointSecurity"];
    /**
     * @description List of gateway environments the API is available
     *
     * @example [
     *   "Production and Sandbox"
     * ]
     */
    gatewayEnvironments?: string[];
    /** @description List of selected deployment environments and clusters */
    deploymentEnvironments?: definitions["DeploymentEnvironments"][];
    /**
     * @description Labels of micro-gateway environments attached to the API.
     *
     * @example []
     */
    labels?: string[];
    /**
     * @example [
     *   {
     *     "name": "json_to_xml_in_message",
     *     "type": "in"
     *   },
     *   {
     *     "name": "xml_to_json_out_message",
     *     "type": "out"
     *   },
     *   {
     *     "name": "json_fault",
     *     "type": "fault"
     *   }
     * ]
     */
    mediationPolicies?: definitions["MediationPolicy"][];
    /**
     * @description The subscription availability. Accepts one of the following. CURRENT_TENANT, ALL_TENANTS or SPECIFIC_TENANTS.
     * @default CURRENT_TENANT
     * @example CURRENT_TENANT
     * @enum {string}
     */
    subscriptionAvailability?:
      | "CURRENT_TENANT"
      | "ALL_TENANTS"
      | "SPECIFIC_TENANTS";
    /** @example [] */
    subscriptionAvailableTenants?: string[];
    /** @description Map of custom properties of API */
    additionalProperties?: { [key: string]: string };
    monetization?: definitions["APIMonetizationInfo"];
    /**
     * @description Is the API is restricted to certain set of publishers or creators or is it visible to all the
     * publishers and creators. If the accessControl restriction is none, this API can be modified by all the
     * publishers and creators, if not it can only be viewable/modifiable by certain set of publishers and creators,
     *  based on the restriction.
     *
     * @default NONE
     * @enum {string}
     */
    accessControl?: "NONE" | "RESTRICTED";
    /**
     * @description The user roles that are able to view/modify as API publisher or creator.
     * @example []
     */
    accessControlRoles?: string[];
    businessInformation?: definitions["APIBusinessInformation"];
    corsConfiguration?: definitions["APICorsConfiguration"];
    /** @example APPROVED */
    workflowStatus?: string;
    /** @example 2017-02-20T13:57:16.229Z */
    createdTime?: string;
    /** @example 2017-02-20T13:57:16.229Z */
    lastUpdatedTime?: string;
    /**
     * @description Endpoint configuration of the API. This can be used to provide different types of endpoints including Simple REST Endpoints, Loadbalanced and Failover.
     *
     * `Simple REST Endpoint`
     *   {
     *     "endpoint_type": "http",
     *     "sandbox_endpoints":       {
     *        "url": "https://localhost:9443/am/sample/pizzashack/v1/api/"
     *     },
     *     "production_endpoints":       {
     *        "url": "https://localhost:9443/am/sample/pizzashack/v1/api/"
     *     }
     *   }
     *
     * `Loadbalanced Endpoint`
     *
     *   {
     *     "endpoint_type": "load_balance",
     *     "algoCombo": "org.apache.synapse.endpoints.algorithms.RoundRobin",
     *     "sessionManagement": "",
     *     "sandbox_endpoints":       [
     *                 {
     *           "url": "https://localhost:9443/am/sample/pizzashack/v1/api/1"
     *        },
     *                 {
     *           "endpoint_type": "http",
     *           "template_not_supported": false,
     *           "url": "https://localhost:9443/am/sample/pizzashack/v1/api/2"
     *        }
     *     ],
     *     "production_endpoints":       [
     *                 {
     *           "url": "https://localhost:9443/am/sample/pizzashack/v1/api/3"
     *        },
     *                 {
     *           "endpoint_type": "http",
     *           "template_not_supported": false,
     *           "url": "https://localhost:9443/am/sample/pizzashack/v1/api/4"
     *        }
     *     ],
     *     "sessionTimeOut": "",
     *     "algoClassName": "org.apache.synapse.endpoints.algorithms.RoundRobin"
     *   }
     *
     * `Failover Endpoint`
     *
     *   {
     *     "production_failovers":[
     *        {
     *           "endpoint_type":"http",
     *           "template_not_supported":false,
     *           "url":"https://localhost:9443/am/sample/pizzashack/v1/api/1"
     *        }
     *     ],
     *     "endpoint_type":"failover",
     *     "sandbox_endpoints":{
     *        "url":"https://localhost:9443/am/sample/pizzashack/v1/api/2"
     *     },
     *     "production_endpoints":{
     *        "url":"https://localhost:9443/am/sample/pizzashack/v1/api/3"
     *     },
     *     "sandbox_failovers":[
     *        {
     *           "endpoint_type":"http",
     *           "template_not_supported":false,
     *           "url":"https://localhost:9443/am/sample/pizzashack/v1/api/4"
     *        }
     *     ]
     *   }
     *
     * `Default Endpoint`
     *
     *   {
     *     "endpoint_type":"default",
     *     "sandbox_endpoints":{
     *        "url":"default"
     *     },
     *     "production_endpoints":{
     *        "url":"default"
     *     }
     *   }
     *
     * `Endpoint from Endpoint Registry`
     *   {
     *     "endpoint_type": "Registry",
     *     "endpoint_id": "{registry-name:entry-name:version}",
     *   }
     *
     * @example {
     *   "endpoint_type": "http",
     *   "sandbox_endpoints": {
     *     "url": "https://localhost:9443/am/sample/pizzashack/v1/api/"
     *   },
     *   "production_endpoints": {
     *     "url": "https://localhost:9443/am/sample/pizzashack/v1/api/"
     *   },
     *   "endpoint_security": {
     *     "sandbox": {
     *       "password": null,
     *       "tokenUrl": "http://localhost:9443/token",
     *       "clientId": "cid123",
     *       "clientSecret": "cs123",
     *       "customParameters": {},
     *       "type": "OAUTH",
     *       "grantType": "CLIENT_CREDENTIALS",
     *       "enabled": true,
     *       "username": null
     *     },
     *     "production": {
     *       "password": null,
     *       "tokenUrl": "http://localhost:9443/token",
     *       "clientId": "cid123",
     *       "clientSecret": "cs123",
     *       "customParameters": {},
     *       "type": "OAUTH",
     *       "grantType": "CLIENT_CREDENTIALS",
     *       "enabled": true,
     *       "username": null
     *     }
     *   }
     * }
     */
    endpointConfig?: { [key: string]: unknown };
    /**
     * @default ENDPOINT
     * @example INLINE
     * @enum {string}
     */
    endpointImplementationType?: "INLINE" | "ENDPOINT";
    scopes?: definitions["APIScope"][];
    /**
     * @example [
     *   {
     *     "target": "/order/{orderId}",
     *     "verb": "POST",
     *     "authType": "Application & Application User",
     *     "throttlingPolicy": "Unlimited"
     *   },
     *   {
     *     "target": "/menu",
     *     "verb": "GET",
     *     "authType": "Application & Application User",
     *     "throttlingPolicy": "Unlimited"
     *   }
     * ]
     */
    operations?: definitions["APIOperations"][];
    threatProtectionPolicies?: {
      list?: {
        policyId?: string;
        priority?: number;
      }[];
    };
    /**
     * @description API categories
     *
     * @example []
     */
    categories?: string[];
    /** @description API Key Managers */
    keyManagers?: { [key: string]: unknown };
  };
  /** Resource for Audit Report */
  AuditReport: {
    /** @description The API Security Audit Report */
    report?: string;
    /**
     * @description The overall grade of the Security Audit
     *
     * @example 27.95
     */
    grade?: string;
    /**
     * @description The number of errors in the API Definition
     *
     * @example 20
     */
    numErrors?: number;
    /**
     * @description The External API ID
     *
     * @example fd21f9f7-3674-49cf-8a83-dca401f635de
     */
    externalApiId?: string;
  };
  /** API Product List */
  APIProductList: {
    /**
     * @description Number of API Products returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["APIProductInfo"][];
    pagination?: definitions["Pagination"];
  };
  /** API Info object with basic API details. */
  APIProductInfo: {
    /**
     * @description UUID of the api product
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id?: string;
    /**
     * @description Name of the API Product
     * @example PizzaShackAPIProduct
     */
    name?: string;
    /** @example pizzaproduct */
    context?: string;
    /**
     * @description A brief description about the API
     * @example This is a simple API for Pizza Shack online pizza delivery store
     */
    description?: string;
    /**
     * @description If the provider value is not given, the user invoking the API will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /** @example true */
    hasThumbnail?: boolean;
    /**
     * @description State of the API product. Only published api products are visible on the store
     *
     * @enum {string}
     */
    state?: "CREATED" | "PUBLISHED";
    /**
     * @description Types of API security, the current API secured with. It can be either OAuth2 or mutual SSL or both. If
     * it is not set OAuth2 will be set as the security for the current API.
     *
     * @example [
     *   "oauth2"
     * ]
     */
    securityScheme?: string[];
  };
  /** API Product object */
  APIProduct: {
    /**
     * @description UUID of the api product
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id?: string;
    /**
     * @description Name of the API Product
     * @example PizzaShackAPIProduct
     */
    name: string;
    /** @example pizzaproduct */
    context?: string;
    /**
     * @description A brief description about the API
     * @example This is a simple API for Pizza Shack online pizza delivery store
     */
    description?: string;
    /**
     * @description If the provider value is not given, the user invoking the API will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /** @example false */
    hasThumbnail?: boolean;
    /**
     * @description State of the API product. Only published api products are visible on the store
     *
     * @enum {string}
     */
    state?: "CREATED" | "PUBLISHED";
    /** @example false */
    enableSchemaValidation?: boolean;
    /** @example true */
    enableStore?: boolean;
    /** @example 8swdwj9080edejhj */
    testKey?: string;
    /** @example true */
    responseCachingEnabled?: boolean;
    /** @example 300 */
    cacheTimeout?: number;
    /**
     * @description The visibility level of the API. Accepts one of the following. PUBLIC, PRIVATE, RESTRICTED.
     * @default PUBLIC
     * @example PUBLIC
     * @enum {string}
     */
    visibility?: "PUBLIC" | "PRIVATE" | "RESTRICTED";
    /**
     * @description The user roles that are able to access the API
     * @example []
     */
    visibleRoles?: string[];
    /** @example [] */
    visibleTenants?: string[];
    /**
     * @description Defines whether the API Product is restricted to certain set of publishers or creators or is it visible to all the
     * publishers and creators. If the accessControl restriction is none, this API Product can be modified by all the
     * publishers and creators, if not it can only be viewable/modifiable by certain set of publishers and creators,
     * based on the restriction.
     *
     * @default NONE
     * @enum {string}
     */
    accessControl?: "NONE" | "RESTRICTED";
    /**
     * @description The user roles that are able to view/modify as API Product publisher or creator.
     * @example []
     */
    accessControlRoles?: string[];
    /**
     * @description List of gateway environments the API Product is available
     *
     * @example [
     *   "Production and Sandbox"
     * ]
     */
    gatewayEnvironments?: string[];
    /**
     * @description The API type to be used. Accepted values are API, APIProduct
     * @example APIProduct
     */
    apiType?: string;
    /**
     * @description Supported transports for the API (http and/or https).
     *
     * @example [
     *   "http",
     *   "https"
     * ]
     */
    transport?: string[];
    /**
     * @example [
     *   "pizza",
     *   "food"
     * ]
     */
    tags?: string[];
    /**
     * @example [
     *   "Unlimited"
     * ]
     */
    policies?: string[];
    /**
     * @description The API level throttling policy selected for the particular API Product
     * @example Unlimited
     */
    apiThrottlingPolicy?: string;
    /**
     * @description Name of the Authorization header used for invoking the API. If it is not set, Authorization header name specified
     * in tenant or system level will be used.
     *
     * @example Authorization
     */
    authorizationHeader?: string;
    /**
     * @description Types of API security, the current API secured with. It can be either OAuth2 or mutual SSL or both. If
     * it is not set OAuth2 will be set as the security for the current API.
     *
     * @example [
     *   "oauth2"
     * ]
     */
    securityScheme?: string[];
    /**
     * @description The subscription availability. Accepts one of the following. CURRENT_TENANT, ALL_TENANTS or SPECIFIC_TENANTS.
     * @default ALL_TENANTS
     * @example CURRENT_TENANT
     * @enum {string}
     */
    subscriptionAvailability?:
      | "CURRENT_TENANT"
      | "ALL_TENANTS"
      | "SPECIFIC_TENANTS";
    /** @example [] */
    subscriptionAvailableTenants?: string[];
    /** @description Map of custom properties of API */
    additionalProperties?: { [key: string]: string };
    monetization?: definitions["APIMonetizationInfo"];
    businessInformation?: definitions["APIProductBusinessInformation"];
    corsConfiguration?: definitions["APICorsConfiguration"];
    /** @example 2017-02-20T13:57:16.229Z */
    createdTime?: string;
    /** @example 2017-02-20T13:57:16.229Z */
    lastUpdatedTime?: string;
    /**
     * @description APIs and resources in the API Product.
     *
     * @example [
     *   {
     *     "name": "PizzaShackAPI",
     *     "apiId": "01234567-0123-0123-0123-012345678901",
     *     "version": "1.0",
     *     "operations": [
     *       {
     *         "target": "/order/{orderId}",
     *         "verb": "POST",
     *         "authType": "Application & Application User",
     *         "throttlingPolicy": "Unlimited"
     *       },
     *       {
     *         "target": "/menu",
     *         "verb": "GET",
     *         "authType": "Application & Application User",
     *         "throttlingPolicy": "Unlimited"
     *       }
     *     ]
     *   }
     * ]
     */
    apis?: definitions["ProductAPI"][];
    /** @example [] */
    scopes?: definitions["APIScope"][];
    /**
     * @description API categories
     *
     * @example []
     */
    categories?: string[];
  };
  /** ProductAPI */
  ProductAPI: {
    /** @example PizzaShackAPI */
    name?: string;
    /** @example 01234567-0123-0123-0123-012345678901 */
    apiId: string;
    /** @example 1 */
    version?: string;
    operations?: definitions["APIOperations"][];
  };
  /** ResourcePath */
  ResourcePath: {
    /** @example 1 */
    id: number;
    /** @example /menu */
    resourcePath?: string;
    /** @example GET */
    httpVerb?: string;
  };
  /** ResourcePath List */
  ResourcePathList: {
    /**
     * @description Number of API Resource Paths returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["ResourcePath"][];
    pagination?: definitions["Pagination"];
  };
  /** APIProduct is outdated status */
  APIProductOutdatedStatus: {
    /**
     * @description Indicates if an API Product is outdated
     *
     * @example true
     */
    isOutdated?: boolean;
  };
  APIProductBusinessInformation: {
    /** @example businessowner */
    businessOwner?: string;
    /** @example businessowner@wso2.com */
    businessOwnerEmail?: string;
    /** @example technicalowner */
    technicalOwner?: string;
    /** @example technicalowner@wso2.com */
    technicalOwnerEmail?: string;
  };
  /** Claim */
  Claim: {
    /** @example email */
    name?: string;
    /** @example http://wso2.org/claims/emailaddress */
    URI?: string;
    /** @example admin@wso2.com */
    value?: string;
  };
  /** SubscriberInfo */
  SubscriberInfo: {
    /** @example admin */
    name?: string;
    claims?: definitions["Claim"][];
  };
  /** Application */
  Application: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    applicationId?: string;
    /** @example CalculatorApp */
    name: string;
    /** @example admin */
    subscriber?: string;
    /** @example Unlimited */
    throttlingTier: string;
    /** @example Sample calculator application */
    description?: string;
    /** @example */
    groupId?: string;
  };
  /** Application info object with basic application details */
  ApplicationInfo: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    applicationId?: string;
    /** @example CalculatorApp */
    name?: string;
    /** @example admin */
    subscriber?: string;
    /** @example Sample calculator application */
    description?: string;
    subscriptionCount?: number;
  };
  /** Document List */
  DocumentList: {
    /**
     * @description Number of Documents returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Document"][];
    pagination?: definitions["Pagination"];
  };
  /** Document */
  Document: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    documentId?: string;
    /** @example PizzaShackDoc */
    name: string;
    /**
     * @example HOWTO
     * @enum {string}
     */
    type:
      | "HOWTO"
      | "SAMPLES"
      | "PUBLIC_FORUM"
      | "SUPPORT_FORUM"
      | "API_MESSAGE_FORMAT"
      | "SWAGGER_DOC"
      | "OTHER";
    /** @example Summary of PizzaShackAPI Documentation */
    summary?: string;
    /**
     * @example INLINE
     * @enum {string}
     */
    sourceType: "INLINE" | "MARKDOWN" | "URL" | "FILE";
    /** @example */
    sourceUrl?: string;
    /** @example */
    fileName?: string;
    /** @example This is doc content. This can have many lines. */
    inlineContent?: string;
    /** @example */
    otherTypeName?: string;
    /**
     * @example API_LEVEL
     * @enum {string}
     */
    visibility: "OWNER_ONLY" | "PRIVATE" | "API_LEVEL";
    /** @example 2017-02-20T13:57:16.229Z */
    createdTime?: string;
    /** @example admin */
    createdBy?: string;
    /** @example 2017-02-20T13:57:16.229Z */
    lastUpdatedTime?: string;
    /** @example admin */
    lastUpdatedBy?: string;
  };
  /** GraphQL Schema */
  GraphQLSchema: {
    /** @example admin--HackerNewsAPI.graphql */
    name: string;
    schemaDefinition?: string;
  };
  /** GraphQL Query Complexity Info */
  GraphQLQueryComplexityInfo: {
    list?: definitions["GraphQLCustomComplexityInfo"][];
  };
  /** GraphQL Custom Complexity Info */
  GraphQLCustomComplexityInfo: {
    /**
     * @description The type found within the schema of the API
     *
     * @example Country
     */
    type: string;
    /**
     * @description The field which is found under the type within the schema of the API
     *
     * @example name
     */
    field: string;
    /**
     * @description The complexity value allocated for the associated field under the specified type
     *
     * @example 1
     */
    complexityValue: number;
  };
  /** List of types and corresponding fields of the GraphQL Schema */
  GraphQLSchemaTypeList: {
    typeList?: definitions["GraphQLSchemaType"][];
  };
  /** Single type and corresponding fields found within the GraphQL Schema */
  GraphQLSchemaType: {
    /**
     * @description Type found within the GraphQL Schema
     *
     * @example Country
     */
    type?: string;
    /**
     * @description Array of fields under current type
     *
     * @example [
     *   "code",
     *   "name"
     * ]
     */
    fieldList?: string[];
  };
  /** Mediation List */
  MediationList: {
    /**
     * @description Number of mediation sequences returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["MediationInfo"][];
    pagination?: definitions["Pagination"];
  };
  /** MediationInfo */
  MediationInfo: {
    /** @example json_fault.xml */
    name: string;
    /** @example 01234567-0123-0123-0123-012345678901 */
    id: string;
    /**
     * @example in
     * @enum {string}
     */
    type: "in" | "out" | "fault";
  };
  /** Mediation */
  Mediation: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example json_fault.xml */
    name: string;
    /**
     * @example in
     * @enum {string}
     */
    type: "in" | "out" | "fault";
  };
  /** Throttling policy list */
  ThrottlingPolicyList: {
    /**
     * @description Number of Tiers returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["ThrottlingPolicy"][];
    pagination?: definitions["Pagination"];
  };
  /** Tier */
  ThrottlingPolicy: {
    /** @example Platinum */
    name: string;
    /** @example Allows 50 request(s) per minute. */
    description?: string;
    /**
     * @example api
     * @enum {string}
     */
    policyLevel?: "subscription" | "api";
    /** @example Platinum */
    displayName?: string;
    /**
     * @description Custom attributes added to the policy policy
     *
     * @example {}
     */
    attributes?: { [key: string]: string };
    /**
     * Format: int64
     * @description Maximum number of requests which can be sent within a provided unit time
     *
     * @example 50
     */
    requestCount: number;
    /**
     * Format: int64
     * @example 60000
     */
    unitTime: number;
    /** @example min */
    timeUnit?: string;
    /**
     * @description This attribute declares whether this policy is available under commercial or free
     *
     * @example FREE
     * @enum {string}
     */
    tierPlan: "FREE" | "COMMERCIAL";
    /**
     * @description By making this attribute to false, you are capabale of sending requests
     * even if the request count exceeded within a unit time
     *
     * @example true
     */
    stopOnQuotaReach: boolean;
    /**
     * @description Properties of a tier plan which are related to monetization
     * @example {}
     */
    monetizationProperties?: { [key: string]: string };
  };
  /** Subscription List */
  SubscriptionList: {
    /**
     * @description Number of Subscriptions returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Subscription"][];
    pagination?: definitions["Pagination"];
  };
  /** Subscription */
  Subscription: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    subscriptionId: string;
    applicationInfo: definitions["ApplicationInfo"];
    /** @example Unlimited */
    throttlingPolicy: string;
    /**
     * @example BLOCKED
     * @enum {string}
     */
    subscriptionStatus:
      | "BLOCKED"
      | "PROD_ONLY_BLOCKED"
      | "UNBLOCKED"
      | "ON_HOLD"
      | "REJECTED";
  };
  /** API monetization usage object */
  APIMonetizationUsage: {
    /** @description Map of custom properties related to monetization usage */
    properties?: { [key: string]: string };
  };
  /** API revenue data object */
  APIRevenue: {
    /** @description Map of custom properties related to API revenue */
    properties?: { [key: string]: string };
  };
  /** Mediation Policy */
  MediationPolicy: {
    /** @example 69ea3fa6-55c6-472e-896d-e449dd34a824 */
    id?: string;
    /** @example log_in_message */
    name: string;
    /** @example in */
    type?: string;
    /** @example true */
    shared?: boolean;
  };
  /** Error object returned with 4XX HTTP Status */
  Error: {
    /** Format: int64 */
    code: number;
    /** @description Error message. */
    message: string;
    /** @description A detail description about the error message. */
    description?: string;
    /** @description Preferably an url with more details about the error. */
    moreInfo?: string;
    /**
     * @description If there are more than one error list them out.
     * For example, list out validation errors by each field.
     */
    error?: definitions["ErrorListItem"][];
  };
  /** Description of individual errors that may have occurred during a request. */
  ErrorListItem: {
    code: string;
    /** @description Description about individual errors occurred */
    message: string;
    /** @description A detail description about the error message. */
    description?: string;
  };
  /** Environment */
  Environment: {
    /** @example Production and Sandbox */
    name: string;
    /** @example hybrid */
    type: string;
    /** @example https://localhost:9443/services/ */
    serverUrl: string;
    /** @example true */
    showInApiConsole: boolean;
    endpoints: definitions["EnvironmentEndpoints"];
  };
  /** Environment List */
  EnvironmentList: {
    /**
     * @description Number of Environments returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Environment"][];
  };
  /** Environment Endpoints */
  EnvironmentEndpoints: {
    /**
     * @description HTTP environment URL
     * @example http://localhost:8280
     */
    http?: string;
    /**
     * @description HTTPS environment URL
     * @example https://localhost:8243
     */
    https?: string;
    /**
     * @description WS environment URL
     * @example http://localhost:9099
     */
    ws?: string;
    /**
     * @description WSS environment URL
     * @example https://localhost:8099
     */
    wss?: string;
  };
  /** File Information including meta data */
  FileInfo: {
    /**
     * @description relative location of the file (excluding the base context and host of the Publisher API)
     * @example apis/01234567-0123-0123-0123-012345678901/thumbnail
     */
    relativePath?: string;
    /**
     * @description media-type of the file
     * @example image/jpeg
     */
    mediaType?: string;
  };
  APIMaxTps: {
    /**
     * Format: int64
     * @example 1000
     */
    production?: number;
    /**
     * Format: int64
     * @example 1000
     */
    sandbox?: number;
  };
  APIEndpointSecurity: {
    /**
     * @description Accepts one of the following, basic or digest.
     * @example BASIC
     * @enum {string}
     */
    type?: "BASIC" | "DIGEST";
    /** @example admin */
    username?: string;
    /** @example password */
    password?: string;
  };
  APIBusinessInformation: {
    /** @example businessowner */
    businessOwner?: string;
    /** @example businessowner@wso2.com */
    businessOwnerEmail?: string;
    /** @example technicalowner */
    technicalOwner?: string;
    /** @example technicalowner@wso2.com */
    technicalOwnerEmail?: string;
  };
  /** @description CORS configuration for the API */
  APICorsConfiguration: {
    /** @default false */
    corsConfigurationEnabled?: boolean;
    accessControlAllowOrigins?: string[];
    /** @default false */
    accessControlAllowCredentials?: boolean;
    accessControlAllowHeaders?: string[];
    accessControlAllowMethods?: string[];
  };
  /** Endpoints */
  Endpoint: {
    /**
     * @description UUID of the Endpoint entry
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id?: string;
    /**
     * @description name of the Endpoint entry
     *
     * @example Endpoint 1
     */
    name?: string;
    endpointConfig?: {
      /**
       * @example FAIL_OVER
       * @enum {string}
       */
      endpointType?: "SINGLE" | "LOAD_BALANCED" | "FAIL_OVER";
      list?: definitions["EndpointConfig"][];
    };
    endpointSecurity?: {
      /** @example false */
      enabled?: boolean;
      /** @example basic */
      type?: string;
      /** @example basic */
      username?: string;
      /** @example basic */
      password?: string;
    };
    /**
     * Format: int64
     * @description Endpoint max tps
     * @example 1000
     */
    maxTps?: number;
    /** @example http */
    type?: string;
  };
  /** Endpoint Configuration */
  EndpointConfig: {
    /**
     * @description Service url of the endpoint
     *
     * @example http://localhost:8280
     */
    url?: string;
    /**
     * @description Time out of the endpoint
     *
     * @example 1000
     */
    timeout?: string;
    attributes?: {
      /** @example Suspension time */
      name?: string;
      /** @example 2s */
      value?: string;
    }[];
  };
  /** Endpoint List */
  EndpointList: {
    /**
     * @description Number of Endpoints returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Endpoint"][];
  };
  /** Scope */
  Scope: {
    /**
     * @description UUID of the Scope. Valid only for shared scopes.
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id?: string;
    /**
     * @description name of Scope
     *
     * @example apim:api_view
     */
    name: string;
    /**
     * @description display name of Scope
     *
     * @example api_view
     */
    displayName?: string;
    /**
     * @description description of Scope
     *
     * @example This Scope can used to view Apis
     */
    description?: string;
    /**
     * @description role bindings list of the Scope
     *
     * @example [
     *   "admin",
     *   "Internal/creator",
     *   "Internal/publisher"
     * ]
     */
    bindings?: string[];
    /**
     * @description usage count of Scope
     *
     * @example 3
     */
    usageCount?: number;
  };
  /** SharedScopeUsage */
  SharedScopeUsage: {
    /**
     * @description UUID of the Scope. Valid only for shared scopes.
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id: string;
    /**
     * @description name of Scope
     *
     * @example apim:api_view
     */
    name: string;
    /** @description API list which have used the shared scope */
    usedApiList?: definitions["SharedScopeUsedAPIInfo"][];
  };
  /** API object using shared scope */
  SharedScopeUsedAPIInfo: {
    /** @example CalculatorAPI */
    name: string;
    /** @example CalculatorAPI */
    context: string;
    /** @example 1.0.0 */
    version: string;
    /**
     * @description If the provider value is not given user invoking the api will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /** @description Resource list which have used the shared scope within this API */
    usedResourceList?: definitions["SharedScopeUsedAPIResourceInfo"][];
  };
  /** API resource object using shared scope */
  SharedScopeUsedAPIResourceInfo: {
    /** @example /add */
    target?: string;
    /** @example POST */
    verb?: string;
  };
  /** APIScope */
  APIScope: {
    scope: definitions["Scope"];
    /**
     * @description States whether scope is shared. This will not be honored when updating/adding scopes to APIs or when
     * adding/updating Shared Scopes.
     *
     * @example true
     */
    shared?: boolean;
  };
  /** Operation */
  APIOperations: {
    /** @example postapiresource */
    id?: string;
    /** @example /order/{orderId} */
    target?: string;
    /** @example POST */
    verb?: string;
    /**
     * @default Any
     * @example Application & Application User
     */
    authType?: string;
    /** @example Unlimited */
    throttlingPolicy?: string;
    /** @example [] */
    scopes?: string[];
    /** @example [] */
    usedProductIds?: string[];
    /** @example */
    amznResourceName?: string;
    amznResourceTimeout?: number;
  };
  /** Scope List */
  ScopeList: {
    /**
     * @description Number of Scopes returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Scope"][];
    pagination?: definitions["Pagination"];
  };
  /** External Store */
  ExternalStore: {
    /**
     * @description The external store identifier, which is a unique value.
     *
     * @example Store123#
     */
    id?: string;
    /**
     * @description The name of the external API Developer Portal that is displayed in the Publisher UI.
     *
     * @example UKStore
     */
    displayName?: string;
    /**
     * @description The type of the API Developer Portal. This can be a WSO2-specific API Developer Portal or an external one.
     *
     * @example wso2
     */
    type?: string;
    /**
     * @description The endpoint URL of the external store
     *
     * @example http://localhost:9764/store
     */
    endpoint?: string;
  };
  /** API External Store */
  APIExternalStore: {
    /**
     * @description The external store identifier, which is a unique value.
     *
     * @example Store123#
     */
    id?: string;
    /**
     * @description The recent timestamp which a given API is updated in the external store.
     *
     * @example 2019-09-09T13:57:16.229Z
     */
    lastUpdatedTime?: string;
  };
  /** API External Store List */
  APIExternalStoreList: {
    /**
     * @description Number of external stores returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["APIExternalStore"][];
  };
  /** External Store List */
  ExternalStoreList: {
    /**
     * @description Number of external stores returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["ExternalStore"][];
  };
  /**
   * Certificates
   * @description Representation of a list of certificates
   */
  Certificates: {
    /** @example 1 */
    count?: number;
    certificates?: definitions["CertMetadata"][];
    pagination?: definitions["Pagination"];
  };
  /**
   * Certificate
   * @description Representation of the details of a certificate
   */
  CertMetadata: {
    /** @example wso2carbon */
    alias?: string;
    /** @example www.abc.com */
    endpoint?: string;
  };
  /** Certificate information */
  CertificateInfo: {
    /** @example Active */
    status?: string;
    validity?: definitions["CertificateValidity"];
    /** @example V3 */
    version?: string;
    /** @example CN=wso2.com, OU=wso2, O=wso2, L=Colombo, ST=Western, C=LK */
    subject?: string;
  };
  /** Certificate Valid period */
  CertificateValidity: {
    /** @example 12-12-2017 */
    from?: string;
    /** @example 01-01-2019 */
    to?: string;
  };
  /**
   * Client Certificates
   * @description Representation of a list of client certificates
   */
  ClientCertificates: {
    /** @example 1 */
    count?: number;
    certificates?: definitions["ClientCertMetadata"][];
    pagination?: definitions["Pagination"];
  };
  /**
   * Client certificate meta data
   * @description Meta data of certificate
   */
  ClientCertMetadata: {
    /** @example wso2carbon */
    alias?: string;
    /** @example 64eca60b-2e55-4c38-8603-e9e6bad7d809 */
    apiId?: string;
    /** @example Gold */
    tier?: string;
  };
  /** Label */
  Label: {
    /** @example marketing_store */
    name: string;
    /** @example Public microgateway for marketing */
    description?: string;
    /** @example https://localhost:9095 */
    access_urls?: string[];
  };
  /** Label List */
  LabelList: {
    /**
     * @description Number of Labels returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Label"][];
    pagination?: definitions["Pagination"];
  };
  /** Lifecycle State */
  LifecycleState: {
    /** @example Created */
    state?: string;
    checkItems?: {
      /** @example Deprecate old versions after publishing the API */
      name?: string;
      /** @example false */
      value?: boolean;
      /** @example [] */
      requiredStates?: string[];
    }[];
    availableTransitions?: {
      /** @example Publish */
      event?: string;
      /** @example Published */
      targetState?: string;
    }[];
  };
  /** Lifecycle history item list */
  LifecycleHistory: {
    /** @example 1 */
    count?: number;
    list?: definitions["LifecycleHistoryItem"][];
  };
  /** Lifecycle history item */
  LifecycleHistoryItem: {
    /** @example Created */
    previousState?: string;
    /** @example Published */
    postState?: string;
    /** @example admin */
    user?: string;
    /**
     * Format: dateTime
     * @example 2019-02-31T23:59:60Z
     */
    updatedTime?: string;
  };
  /** workflow Response */
  WorkflowResponse: {
    /**
     * @description This attribute declares whether this workflow task is approved or rejected.
     *
     * @example APPROVED
     * @enum {string}
     */
    workflowStatus: "CREATED" | "APPROVED" | "REJECTED" | "REGISTERED";
    /**
     * @description Attributes that returned after the workflow execution
     *
     * @example null
     */
    jsonPayload?: string;
    lifecycleState?: definitions["LifecycleState"];
  };
  /** OpenAPI Definition Validation Response */
  OpenAPIDefinitionValidationResponse: {
    /**
     * @description This attribute declares whether this definition is valid or not.
     *
     * @example true
     */
    isValid: boolean;
    /** @description OpenAPI definition content. */
    content?: string;
    /** @description API definition information */
    info?: {
      /** @example PetStore */
      name?: string;
      /** @example 1.0.0 */
      version?: string;
      /** @example /petstore */
      context?: string;
      /** @example A sample API that uses a petstore as an example to demonstrate swagger-2.0 specification */
      description?: string;
      /** @example 3.0.0 */
      openAPIVersion?: string;
      /** @description contains host/servers specified in the OpenAPI file/URL */
      endpoints?: string[];
    };
    /**
     * @description If there are more than one error list them out.
     * For example, list out validation errors by each field.
     */
    errors?: definitions["ErrorListItem"][];
  };
  /** WSDL Definition Validation Response */
  WSDLValidationResponse: {
    /**
     * @description This attribute declares whether this definition is valid or not.
     *
     * @example true
     */
    isValid: boolean;
    /**
     * @description If there are more than one error list them out.
     * For example, list out validation errors by each field.
     */
    errors?: definitions["ErrorListItem"][];
    /** @description Summary of the WSDL including the basic information */
    wsdlInfo?: {
      /**
       * @description WSDL version
       *
       * @example 1.1
       */
      version?: string;
      /** @description A list of endpoints the service exposes */
      endpoints?: {
        /**
         * @description Name of the endpoint
         * @example StockQuoteSoap
         */
        name?: string;
        /**
         * @description Endpoint URL
         * @example http://www.webservicex.net/stockquote.asmx
         */
        location?: string;
      }[];
    };
  };
  /** GraphQL API definition validation Response */
  GraphQLValidationResponse: {
    /**
     * @description This attribute declares whether this definition is valid or not.
     *
     * @example true
     */
    isValid: boolean;
    /** @description This attribute declares the validation error message */
    errorMessage: string;
    /** @description Summary of the GraphQL including the basic information */
    graphQLInfo?: {
      operations?: definitions["APIOperations"][];
      graphQLSchema?: definitions["GraphQLSchema"];
    };
  };
  /** API Endpoint url validation response */
  ApiEndpointValidationResponse: {
    /**
     * @description HTTP status code
     * @example 200
     */
    statusCode: number;
    /**
     * @description string
     * @example OK
     */
    statusMessage: string;
    /**
     * @description If an error occurs, the error message will be set to this property.
     * If not, this will remain null.
     *
     * @example null
     */
    error?: string;
  };
  /** Threat Protection Policy List */
  ThreatProtectionPolicyList: {
    list?: definitions["ThreatProtectionPolicy"][];
  };
  /** Threat Protection Policy Schema */
  ThreatProtectionPolicy: {
    /** @description Policy ID */
    uuid?: string;
    /** @description Name of the policy */
    name: string;
    /** @description Type of the policy */
    type: string;
    /** @description policy as a json string */
    policy: string;
  };
  /** Unified Search Result List */
  SearchResultList: {
    /**
     * @description Number of results returned.
     *
     * @example 1
     */
    count?: number;
    list?: (Partial<definitions["APISearchResult"]> &
      Partial<definitions["APIProductSearchResult"]> &
      Partial<definitions["DocumentSearchResult"]>)[];
    pagination?: definitions["Pagination"];
  };
  /** Search Result */
  SearchResult: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example TestAPI */
    name: string;
    /**
     * @example API
     * @enum {string}
     */
    type?: "DOC" | "API" | "APIProduct";
    /** @description Accepted values are HTTP, WS, SOAPTOREST, GRAPHQL */
    transportType?: string;
  };
  /** API Result */
  APISearchResult: definitions["SearchResult"] & {
    /**
     * @description A brief description about the API
     * @example A calculator API that supports basic operations
     */
    description?: string;
    /**
     * @description A string that represents the context of the user's request
     * @example CalculatorAPI
     */
    context?: string;
    /**
     * @description The version of the API
     * @example 1.0.0
     */
    version?: string;
    /**
     * @description If the provider value is not given, the user invoking the API will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /**
     * @description This describes in which status of the lifecycle the API is
     * @example CREATED
     */
    status?: string;
    /** @example /apis/01234567-0123-0123-0123-012345678901/thumbnail */
    thumbnailUri?: string;
  };
  /** API Result */
  APIProductSearchResult: definitions["SearchResult"] & {
    /**
     * @description A brief description about the API
     * @example A calculator API that supports basic operations
     */
    description?: string;
    /**
     * @description A string that represents the context of the user's request
     * @example CalculatorAPI
     */
    context?: string;
    /**
     * @description The version of the API Product
     * @example 1.0.0
     */
    version?: string;
    /**
     * @description If the provider value is not given, the user invoking the API will be used as the provider.
     *
     * @example admin
     */
    provider?: string;
    /**
     * @description This describes in which status of the lifecycle the APIPRODUCT is
     * @example PUBLISHED
     */
    status?: string;
    /** @example /apis/01234567-0123-0123-0123-012345678901/thumbnail */
    thumbnailUri?: string;
  };
  /** API monetization object */
  APIMonetizationInfo: {
    /**
     * @description Flag to indicate the monetization status
     * @example true
     */
    enabled: boolean;
    /** @description Map of custom properties related to monetization */
    properties?: { [key: string]: string };
  };
  /** Document Result */
  DocumentSearchResult: definitions["SearchResult"] & {
    /**
     * @example HOWTO
     * @enum {string}
     */
    docType?:
      | "HOWTO"
      | "SAMPLES"
      | "PUBLIC_FORUM"
      | "SUPPORT_FORUM"
      | "API_MESSAGE_FORMAT"
      | "SWAGGER_DOC"
      | "OTHER";
    /** @example Summary of Calculator Documentation */
    summary?: string;
    /**
     * @example INLINE
     * @enum {string}
     */
    sourceType?: "INLINE" | "URL" | "FILE";
    /** @example */
    sourceUrl?: string;
    /** @example */
    otherTypeName?: string;
    /**
     * @example API_LEVEL
     * @enum {string}
     */
    visibility?: "OWNER_ONLY" | "PRIVATE" | "API_LEVEL";
    /**
     * @description The name of the associated API
     * @example TestAPI
     */
    apiName?: string;
    /**
     * @description The version of the associated API
     * @example 1.0.0
     */
    apiVersion?: string;
    /** @example admin */
    apiProvider?: string;
    apiUUID?: string;
    associatedType?: string;
  };
  /** Mock Response Payload list */
  MockResponsePayloadList: {
    list?: definitions["MockResponsePayloadInfo"][];
  };
  /** Mock Response Payload info object */
  MockResponsePayloadInfo: {
    /**
     * @description path of the resource
     * @example /menu
     */
    path?: string;
    /**
     * @description new modified code
     * @example var accept = "\""+mc.getProperty('AcceptHeader')+"\"";
     * var responseCode = mc.getProperty('query.param.responseCode');
     * var responseCodeStr = "\""+responseCode+"\"";
     * var responses = [];
     *
     * if (!responses[200]) {
     *  responses [200] = [];
     * }
     * responses[200]["application/json"] =
     * [ {
     *   "price" : "string",
     *   "description" : "string",
     *   "name" : "string",
     *   "image" : "string"
     * } ]
     *
     * /*if (!responses[304]) {
     *   responses[304] = [];
     * }
     * responses[304]["application/(json or xml)"] = {}/<>*\/
     *
     * if (!responses[406]) {
     *  responses [406] = [];
     * }
     * responses[406]["application/json"] =
     * {
     *   "message" : "string",
     *   "error" : [ {
     *     "message" : "string",
     *     "code" : 0
     *   } ],
     *   "description" : "string",
     *   "code" : 0,
     *   "moreInfo" : "string"
     * }
     *
     * responses[501] = [];
     * responses[501]["application/json"] = {
     * "code" : 501,
     * "description" : "Not Implemented"}
     * responses[501]["application/xml"] = <response><code>501</code><description>Not Implemented</description></response>;
     *
     * if (!responses[responseCode]) {
     *  responseCode = 501;
     * }
     *
     * if (responseCode == null) {
     *  responseCode = 200;
     *  responseCodeStr = "200";
     * }
     *
     * if (accept == null || !responses[responseCode][accept]) {
     *  accept = "application/json";
     * }
     *
     * if (accept === "application/json") {
     *  mc.setProperty('CONTENT_TYPE', 'application/json');
     *  mc.setProperty('HTTP_SC', responseCodeStr);
     *  mc.setPayloadJSON(responses[responseCode]["application/json"]);
     * } else if (accept === "application/xml") {
     *  mc.setProperty('CONTENT_TYPE', 'application/xml');
     *  mc.setProperty('HTTP_SC', responseCodeStr);
     *  mc.setPayloadXML(responses[responseCode]["application/xml"]);
     * }
     */
    content?: string;
    /** @example POST */
    verb?: string;
  };
  /** Resource policy List */
  ResourcePolicyList: {
    list?: definitions["ResourcePolicyInfo"][];
    /**
     * @description Number of policy resources returned.
     *
     * @example 1
     */
    count?: number;
  };
  /** Resource policy Info object with conversion policy resource details. */
  ResourcePolicyInfo: {
    /**
     * @description UUID of the resource policy registry artifact
     *
     * @example 01234567-0123-0123-0123-012345678901
     */
    id?: string;
    /**
     * @description HTTP verb used for the resource path
     * @example get
     */
    httpVerb?: string;
    /**
     * @description A string that represents the resource path of the api for the related resource policy
     * @example checkPhoneNumber
     */
    resourcePath?: string;
    /**
     * @description The resource policy content
     * @example <header description="SOAPAction" name="SOAPAction" scope="transport" value="http://ws.cdyne.com/PhoneVerify/query/CheckPhoneNumber"/>
     */
    content?: string;
  };
  /** SettingsDTO */
  Settings: {
    /**
     * @description Store URL
     * @example https://localhost:9443/devportal
     */
    storeUrl?: string;
    environment?: definitions["Environment"][];
    /**
     * @example [
     *   "apim:api_create",
     *   "apim:api_publish"
     * ]
     */
    scopes?: string[];
    /** @example [] */
    monetizationAttributes?: definitions["MonetizationAttribute"][];
    securityAuditProperties?: string[];
    /**
     * @description Is External Stores configuration enabled
     *
     * @example true
     */
    externalStoresEnabled?: boolean;
    /**
     * @description Is Document Visibility configuration enabled
     *
     * @example false
     */
    docVisibilityEnabled?: boolean;
    /**
     * @description Is Cross Tenant Subscriptions Enabled
     *
     * @default false
     * @example false
     */
    crossTenantSubscriptionEnabled?: boolean;
    deployments?: definitions["Deployments"][];
  };
  /** SecurityAuditAttributeDTO */
  SecurityAuditAttribute: {
    /** @example false */
    isGlobal?: boolean;
    /** @example false */
    overrideGlobal?: boolean;
    /** @example b1267ytf-b7gc-4aee-924d-ece81241efec */
    apiToken?: string;
    /** @example 456ef957-5a79-449f-83y3-9027945d3c60 */
    collectionId?: string;
    baseUrl?: string;
  };
  /** WSDL information of the API. This is only available if the API is a SOAP API. */
  WSDLInfo: {
    /**
     * @description Indicates whether the WSDL is a single WSDL or an archive in ZIP format
     * @enum {string}
     */
    type?: "WSDL" | "ZIP";
  };
  /** Pagination */
  Pagination: {
    /** @example 0 */
    offset?: number;
    /** @example 1 */
    limit?: number;
    /** @example 10 */
    total?: number;
    /**
     * @description Link to the next subset of resources qualified.
     * Empty if no more resources are to be returned.
     */
    next?: string;
    /**
     * @description Link to the previous subset of resources qualified.
     * Empty if current subset is the first subset returned.
     */
    previous?: string;
  };
  /** Monetization attribute object */
  MonetizationAttribute: {
    /**
     * @description Is attribute required
     *
     * @example true
     */
    required?: boolean;
    /** @description Name of the attribute */
    name?: string;
    /** @description Display name of the attribute */
    displayName?: string;
    /** @description Description of the attribute */
    description?: string;
    /** @description Is attribute hidden */
    hidden?: boolean;
    /** @description Default value of the attribute */
    default?: string;
  };
  /** Tenant */
  Tenant: {
    /**
     * @description tenant domain
     * @example wso2.com
     */
    domain?: string;
    /**
     * @description current status of the tenant active/inactive
     * @example active
     */
    status?: string;
  };
  /** Tenant list */
  TenantList: {
    /**
     * @description Number of tenants returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Tenant"][];
    pagination?: definitions["Pagination"];
  };
  /** Alert Types List */
  AlertTypesList: {
    /**
     * @description The number of alerts
     * @example 3
     */
    count?: number;
    alerts?: definitions["AlertType"][];
  };
  /** Alert Type */
  AlertType: {
    /**
     * @description The alert Id
     * @example 1
     */
    id?: number;
    /**
     * @description The name of the alert.
     * @example AbnormalRequestTime
     */
    name?: string;
    /**
     * @description Whether the alert type require additional configurations.
     * @example true
     */
    requireConfiguration?: boolean;
  };
  /** Alert */
  Alert: {
    /**
     * @description The alert Id
     * @example 1
     */
    id?: number;
    /**
     * @description The name of the alert.
     * @example AbnormalRequestsPerMin
     */
    name?: string;
    configuration?: definitions["AlertConfig"][];
  };
  /** Alerts Info */
  AlertsInfo: {
    alerts?: definitions["Alert"][];
    emailList?: string[];
  };
  /** Alerts Info Response */
  AlertsInfoResponse: {
    alerts?: definitions["Alert"][];
    emailList?: string[];
    failedConfigurations?: definitions["AlertConfig"][];
  };
  /** Alert Configuration List */
  AlertConfigList: {
    /** @example 1 */
    count?: number;
    list?: definitions["AlertConfig"][];
  };
  /** Alert Configuration */
  AlertConfig: {
    /**
     * @description The alert config subscription id.
     * @example UGl6emFTaGFja0FQSSsxLjAuMCtEZWZhdWx0QXBwbGljYXRpb24K
     */
    configurationId?: string;
    /**
     * @description The config parameters.
     * @example {
     *   "apiName": "PizzaShackAPI",
     *   "apiVersion": "1.0.0",
     *   "applicationName": "DefaultApplication",
     *   "requestConunt": "12"
     * }
     */
    configuration?: { [key: string]: string };
  };
  /**
   * Alert Configuration Info
   * @description The config parameters.
   * @example {
   *   "apiName": "PizzaShackAPI",
   *   "apiVersion": "1.0.0",
   *   "applicationName": "DefaultApplication",
   *   "requestConunt": "12"
   * }
   */
  AlertConfigInfo: { [key: string]: string };
  /** API Category */
  APICategory: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example Finance */
    name: string;
    /** @example Finance related APIs */
    description?: string;
  };
  /** API Category List */
  APICategoryList: {
    /**
     * @description Number of API categories returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["APICategory"][];
  };
  /** Key Manager Info */
  KeyManagerInfo: {
    /** @example 01234567-0123-0123-0123-012345678901 */
    id?: string;
    /** @example WSO2 IS */
    name: string;
    /**
     * @description display name of Keymanager
     *
     * @example Keymanager1
     */
    displayName?: string;
    /** @example IS */
    type: string;
    /** @example This is a key manager for Developers */
    description?: string;
    /** @example true */
    enabled?: boolean;
    additionalProperties?: { [key: string]: unknown }[];
  };
  /** Key Manager List */
  KeyManagerList: {
    /**
     * @description Number of Key managers returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["KeyManagerInfo"][];
  };
  /** Deployment List */
  DeploymentList: {
    /**
     * @description Number of deployment clusters returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["Deployments"][];
  };
  /** Deployments */
  Deployments: {
    /** @example Kubernetes */
    name: string;
    clusters: definitions["DeploymentClusterInfo"][];
  };
  /** DeploymentClusterInfo */
  DeploymentClusterInfo: {
    /** @example minikube */
    clusterName: string;
    /** @example https://api.com */
    accessURL: string;
    /** @example kubernetes-minikube */
    displayName: string;
    properties: { [key: string]: string };
  };
  /** DeploymentStatus List */
  DeploymentStatusList: {
    /**
     * @description Status of the deployments returned.
     *
     * @example 1
     */
    count?: number;
    list?: definitions["DeploymentStatus"][];
  };
  /** DeploymentStatus */
  DeploymentStatus: {
    /** @example Kubernetes */
    type: string;
    clusters: definitions["DeploymentClusterStatus"][];
  };
  /** DeploymentClusterStatus */
  DeploymentClusterStatus: {
    /** @example Minikube */
    clusterName: string;
    /** @default 0 */
    podsRunning: number;
    healthStatus: definitions["PodStatus"][];
  };
  /** DeploymentEnvironments */
  DeploymentEnvironments: {
    /** @example Kubernetes */
    type: string;
    /**
     * @example [
     *   "minikube"
     * ]
     */
    clusterName: string[];
  };
  /** PodStatus */
  PodStatus: {
    /** @example petStore-677bb7cc65-shb2f */
    name: string;
    /** @example 1/1 */
    ready: string;
    /** @example running */
    status: string;
    /** @example 2020-05-12T06:12:00.000Z */
    creationTimestamp?: string;
  } & {
    age: unknown;
  };
}

export interface parameters {
  /** @description **API ID** consisting of the **UUID** of the API. */
  apiId: string;
  /** @description **Endpoint ID** consisting of the **UUID** of the Endpoint**. */
  endpointId: string;
  /**
   * @description **API ID** consisting of the **UUID** of the API.
   * The combination of the provider of the API, name of the API and the version is also accepted as a valid API I.
   * Should be formatted as **provider-name-version**.
   */
  "apiId-Q": string;
  /**
   * @description **API ID** consisting of the **UUID** of the API.
   * The combination of the provider of the API, name of the API and the version is also accepted as a valid API I.
   * Should be formatted as **provider-name-version**.
   */
  "apiId-Q-Opt": string;
  /**
   * @description **API ID** consisting of the **UUID** of the API.
   * The combination of the provider of the API, name of the API and the version is also accepted as a valid API I.
   * Should be formatted as **provider-name-version**.
   */
  "labelType-Q": string;
  /** @description Name of the API */
  name: string;
  /** @description Version of the API */
  version: string;
  /** @description Document Identifier */
  documentId: string;
  /** @description **Application Identifier** consisting of the UUID of the Application. */
  applicationId: string;
  /** @description Subscription Id */
  subscriptionId: string;
  /** @description Mediation policy Id */
  mediationPolicyId: string;
  /** @description registry resource Id */
  resourcePolicyId: string;
  /** @description Subscription Id */
  "subscriptionId-Q": string;
  /** @description Tier name */
  policyName: string;
  /** @description Name of the policy */
  "policyName-Q": string;
  /**
   * @description List API or Application or Resource type policies.
   *
   * @enum {string}
   */
  policyLevel: "api" | "subcription";
  /**
   * @description List API or Application or Resource type policies.
   *
   * @enum {string}
   */
  "policyLevel-Q": "api" | "subcription";
  /**
   * @description Maximum size of resource array to return.
   *
   * @default 25
   */
  limit: number;
  /**
   * @description Media types acceptable for the response. Default is application/json.
   *
   * @default application/json
   */
  Accept: string;
  /**
   * @description Starting point within the complete list of items qualified.
   *
   * @default 0
   */
  offset: number;
  /**
   * @description Validator for conditional requests; based on the ETag of the formerly retrieved
   * variant of the resource.
   */
  "If-None-Match": string;
  /** @description Validator for conditional requests; based on ETag. */
  "If-Match": string;
  /** @description Scope name */
  scopeName: string;
  /** @description Scope Id consisting the UUID of the shared scope */
  scopeId: string;
  /** @description Defines whether the returned response should contain full details of API */
  expand: boolean;
  /** @description The UUID of a Policy */
  threatProtectionPolicyId: string;
  /**
   * @description The Base 64 URL encoded role name with domain. If the given role is in secondary user-store, role ID should be
   * derived as Base64URLEncode({user-store-name}/{role-name}). If the given role is in PRIMARY user-store, role ID
   * can be derived as Base64URLEncode(role-name)
   */
  roleId: string;
  /** @description Threat protection policy request parameter */
  threatProtectionPolicy: definitions["ThreatProtectionPolicy"];
  /**
   * @description For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
   *   retirieved from.
   */
  requestedTenant: string;
  /** @description **API Product ID** consisting of the **UUID** of the API Product. Using the **UUID** in the API call is recommended. */
  apiProductId: string;
  /** @description The domain of a specific tenant */
  tenantDomain: string;
  /** @description The alert type. */
  alertType: string;
  /** @description The alert configuration id. */
  configurationId: string;
}

export interface responses {
  /** Bad Request. Invalid request or validation error. */
  BadRequest: {
    schema: definitions["Error"];
  };
  /** Unauthorized. The user is not authorized. */
  Unauthorized: {
    schema: definitions["Error"];
  };
  /** Forbidden. The request must be conditional but no condition has been specified. */
  Forbidden: {
    schema: definitions["Error"];
  };
  /** Not Found. The specified resource does not exist. */
  NotFound: {
    schema: definitions["Error"];
  };
  /** Not Acceptable. The requested media type is not supported. */
  NotAcceptable: {
    schema: definitions["Error"];
  };
  /** Conflict. Specified resource already exists. */
  Conflict: {
    schema: definitions["Error"];
  };
  /** Precondition Failed. The request has not been performed because one of the preconditions is not met. */
  PreconditionFailed: {
    schema: definitions["Error"];
  };
  /** Unsupported Media Type. The entity of the request was not in a supported format. */
  UnsupportedMediaType: {
    schema: definitions["Error"];
  };
  /** Internal Server Error. */
  InternalServerError: {
    schema: definitions["Error"];
  };
}

export interface operations {
  /** This operation can be used to generate mock responses from examples of swagger definition of an API. */
  generateMockScripts: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Requested swagger document of the API is returned with example responses
       */
      200: {
        headers: {};
        schema: string;
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses["NotFound"];
      406: responses["NotAcceptable"];
    };
  };
  /** This operation can be used to get generated mock responses from examples of swagger definition of an API. */
  getGeneratedMockScriptsOfAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Requested swagger document of the API is returned with example responses
       */
      200: {
        headers: {};
        schema: definitions["MockResponsePayloadList"];
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses["NotFound"];
      406: responses["NotAcceptable"];
    };
  };
  /** This operation can be used to upload a thumbnail image of an API. The thumbnail to be uploaded should be given as a form data parameter `file`. */
  updateAPIThumbnail: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      formData: {
        /** Image to upload */
        file: unknown;
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        "If-Match"?: parameters["If-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Image updated
       */
      200: {
        headers: {};
        schema: definitions["FileInfo"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
    };
  };
  /**
   * This operation can be used to create an API from an OpenAPI definition. Provide either `url` or `file`
   * to specify the definition.
   *
   * Specify additionalProperties with **at least** API's name, version, context and endpointConfig.
   */
  importOpenAPIDefinition: {
    parameters: {
      formData: {
        /** Definition to upload as a file */
        file?: unknown;
        /** Definition url */
        url?: string;
        /** Additional attributes specified as a stringified JSON with API's schema */
        additionalProperties?: string;
      };
    };
    responses: {
      /**
       * Created.
       * Successful response with the newly created object as entity in the body.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {};
        schema: definitions["API"];
      };
      400: responses["BadRequest"];
      415: responses["UnsupportedMediaType"];
    };
  };
  /**
   * This operation can be used to create an API using a WSDL definition. Provide either `url` or `file`
   * to specify the definition.
   *
   * WSDL can be speficied as a single file or a ZIP archive with WSDLs and reference XSDs etc.
   * Specify additionalProperties with **at least** API's name, version, context and endpointConfig.
   */
  importWSDLDefinition: {
    parameters: {
      formData: {
        /**
         * WSDL definition as a file or archive
         *
         * **Sample cURL to Upload WSDL File**
         *
         * curl -k -H "Authorization: Bearer ae4eae22-3f65-387b-a171-d37eaa366fa8" -F file=@api.wsdl -F additionalProperties=@data.json "https://127.0.0.1:9443/api/am/publisher/v1/apis/import-wsdl"
         *
         * **Sample cURL to Upload WSDL Archive**
         *
         * curl -k -H "Authorization: Bearer ae4eae22-3f65-387b-a171-d37eaa366fa8" -F file="@wsdl.zip;type=application/zip" -F additionalProperties=@data.json "https://127.0.0.1:9443/api/am/publisher/v1/apis/import-wsdl"
         */
        file?: unknown;
        /** WSDL Definition URL */
        url?: string;
        /** Additional attributes specified as a stringified JSON with API's schema */
        additionalProperties?: string;
        /**
         * If 'SOAP' is specified, the API will be created with only one resource 'POST /*' which is to be used for SOAP
         * operations.
         *
         * If 'HTTP_BINDING' is specified, the API will be created with resources using HTTP binding operations
         * which are extracted from the WSDL.
         */
        implementationType?: "SOAPTOREST" | "SOAP";
      };
    };
    responses: {
      /**
       * Created.
       * Successful response with the newly created object as entity in the body.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {};
        schema: definitions["API"];
      };
      400: responses["BadRequest"];
      415: responses["UnsupportedMediaType"];
    };
  };
  /**
   * This operation can be used to validate an OpenAPI definition and retrieve a summary. Provide either `url`
   * or `file` to specify the definition.
   */
  validateOpenAPIDefinition: {
    parameters: {
      formData: {
        /** OpenAPI definition url */
        url?: string;
        /** OpenAPI definition as a file */
        file?: unknown;
      };
      query: {
        /**
         * Specify whether to return the full content of the OpenAPI definition in the response. This is only
         * applicable when using url based validation
         */
        returnContent?: boolean;
      };
    };
    responses: {
      /**
       * OK.
       * API definition validation information is returned
       */
      200: {
        headers: {};
        schema: definitions["OpenAPIDefinitionValidationResponse"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
    };
  };
  /** Using this operation, it is possible check whether the given API endpoint url is a valid url */
  validateEndpoint: {
    parameters: {
      query: {
        /** API endpoint url */
        endpointUrl: string;
        apiId?: string;
      };
    };
    responses: {
      /**
       * OK.
       * API definition validation information is returned
       */
      200: {
        headers: {};
        schema: definitions["ApiEndpointValidationResponse"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
    };
  };
  /** Using this operation, you can check a given API context is already used. You need to provide the context name you want to check. */
  validateAPI: {
    parameters: {
      query: {
        /**
         * **Search condition**.
         *
         * You can search in attributes by using an **"<attribute>:"** modifier.
         *
         * Eg.
         * "name:wso2" will match an API if the provider of the API is exactly "wso2".
         *
         * Supported attribute modifiers are [** version, context, name **]
         *
         * If no advanced attribute modifier has been specified, search will match the
         * given query string against API Name.
         */
        query: string;
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * API definition validation information is returned
       */
      200: unknown;
      400: responses["BadRequest"];
      404: responses["NotFound"];
    };
  };
  /**
   * This operation can be used to validate a WSDL definition and retrieve a summary. Provide either `url`
   * or `file` to specify the definition.
   */
  validateWSDLDefinition: {
    parameters: {
      formData: {
        /** Definition url */
        url?: string;
        /** Definition to upload as a file */
        file?: unknown;
      };
    };
    responses: {
      /**
       * OK.
       * API definition validation information is returned
       */
      200: {
        headers: {};
        schema: definitions["WSDLValidationResponse"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
    };
  };
  /** This operation can be used to verify the document name exists or not. */
  validateDocument: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      query: {
        /** The name of the document which needs to be checked for the existance. */
        name: string;
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        "If-Match"?: parameters["If-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Successful response if the document name exists.
       */
      200: unknown;
      400: responses["BadRequest"];
      /**
       * Not Found.
       * The specified resource does not exist.
       */
      404: unknown;
    };
  };
  /** This operation provides you a list of available mediation policies of an API. */
  apisApiIdMediationPoliciesGet: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      query: {
        /** Maximum size of resource array to return. */
        limit?: parameters["limit"];
        /** Starting point within the complete list of items qualified. */
        offset?: parameters["offset"];
        /** -Not supported yet- */
        query?: string;
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * List of qualifying APIs is returned.
       */
      200: {
        headers: {};
        schema: definitions["MediationList"];
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      406: responses["NotAcceptable"];
    };
  };
  /** This operation can be used to add an API specifc mediation policy. */
  apisApiIdMediationPoliciesPost: {
    parameters: {
      formData: {
        /** Mediation Policy to upload */
        mediationPolicyFile?: unknown;
        /** Inline content of the Mediation Policy */
        inlineContent?: string;
        /** Type of the mediation sequence */
        type: string;
      };
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        "If-Match"?: parameters["If-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * mediation policy uploaded
       */
      201: {
        headers: {};
        schema: definitions["Mediation"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
    };
  };
  /** This operation can be used to retrieve a particular API specific mediation policy. */
  apisApiIdMediationPoliciesMediationPolicyIdGet: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
        /** Mediation policy Id */
        mediationPolicyId: parameters["mediationPolicyId"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Mediation policy returned.
       */
      200: {
        headers: {};
        schema: definitions["Mediation"];
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses["NotFound"];
      406: responses["NotAcceptable"];
    };
  };
  /** This operation can be used to delete an existing API specific mediation policy providing the Id of the API and the Id of the mediation policy. */
  apisApiIdMediationPoliciesMediationPolicyIdDelete: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
        /** Mediation policy Id */
        mediationPolicyId: parameters["mediationPolicyId"];
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        "If-Match"?: parameters["If-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Resource successfully deleted.
       */
      200: unknown;
      403: responses["Forbidden"];
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
    };
  };
  /** This operation can be used to download a particular API specific mediation policy. */
  apisApiIdMediationPoliciesMediationPolicyIdContentGet: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
        /** Mediation policy Id */
        mediationPolicyId: parameters["mediationPolicyId"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Mediation policy returned.
       */
      200: unknown;
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses["NotFound"];
    };
  };
  /** This operation can be used to update an existing mediation policy of an API. */
  apisApiIdMediationPoliciesMediationPolicyIdContentPut: {
    parameters: {
      formData: {
        /** Mediation Policy to upload */
        file?: unknown;
        /** Inline content of the Mediation Policy */
        inlineContent?: string;
        /** Type of the mediation sequence(in/out/fault) */
        type: string;
      };
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
        /** Mediation policy Id */
        mediationPolicyId: parameters["mediationPolicyId"];
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        "If-Match"?: parameters["If-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Successful response with updated API object
       */
      200: {
        headers: {};
        schema: definitions["Mediation"];
      };
      400: responses["BadRequest"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
    };
  };
  /**
   * This operation can be used to retrieve the WSDL meta information of an API. It states whether the API is a SOAP
   * API. If the API is a SOAP API, it states whether it has a single WSDL or a WSDL archive.
   */
  getWSDLInfoOfAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
    };
    responses: {
      /**
       * OK.
       * Requested WSDL meta information of the API is returned
       */
      200: {
        schema: definitions["WSDLInfo"];
      };
      404: responses["NotFound"];
      406: responses["NotAcceptable"];
    };
  };
  /**
   * This operation can be used to retrieve the WSDL definition of an API. It can be either a single WSDL file or a WSDL archive.
   *
   * The type of the WSDL of the API is indicated at the "wsdlInfo" element of the API payload definition.
   */
  getWSDLOfAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Requested WSDL document of the API is returned
       */
      200: unknown;
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses["NotFound"];
      406: responses["NotAcceptable"];
    };
  };
  /**
   * This operation can be used to update the WSDL definition of an existing API. WSDL to be updated can be passed as either "url" or "file".
   * Only one of "url" or "file" can be used at the same time. "file" can be specified as a single WSDL file or as a zip file which has a WSDL
   * and its dependencies (eg: XSDs)
   */
  updateWSDLOfAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      formData: {
        /** WSDL file or archive to upload */
        file?: unknown;
        /** WSDL Definition url */
        url?: string;
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        "If-Match"?: parameters["If-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Successful response with updated WSDL definition
       */
      200: unknown;
      400: responses["BadRequest"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
    };
  };
  /** This operation can be used to retrieve a list of external stores which an API is published to by providing the id of the API. */
  getAllPublishedExternalStoresByAPI: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * External Store list is returned.
       */
      200: {
        headers: {};
        schema: definitions["APIExternalStoreList"];
      };
      404: responses["NotFound"];
      500: responses["InternalServerError"];
    };
  };
  /** This operation can be used to publish an API to a list of external stores. */
  publishAPIToExternalStores: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
      query: {
        /** External Store Ids of stores which the API needs to be published or updated. */
        externalStoreIds: string;
      };
      header: {
        /** Validator for conditional requests; based on ETag. */
        "If-Match"?: parameters["If-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * API was successfully published to all the selected external stores.
       */
      200: {
        headers: {};
        schema: definitions["APIExternalStoreList"];
      };
      404: responses["NotFound"];
      500: responses["InternalServerError"];
    };
  };
  /**
   * This operation can be used to list the available policies for a given policy level. Tier level should be specified as a path parameter and should be one of `subscription` and `api`.
   * `subscription` is for Subscription Level policies and `api` is for Resource Level policies
   */
  getAllThrottlingPolicies: {
    parameters: {
      query: {
        /** Maximum size of resource array to return. */
        limit?: parameters["limit"];
        /** Starting point within the complete list of items qualified. */
        offset?: parameters["offset"];
      };
      path: {
        /** List API or Application or Resource type policies. */
        policyLevel: parameters["policyLevel"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * List of policies returned.
       */
      200: {
        headers: {};
        schema: definitions["ThrottlingPolicyList"];
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      406: responses["NotAcceptable"];
    };
  };
  /** This operation can be used to retrieve details of a single policy by specifying the policy level and policy name. */
  getThrottlingPolicyByName: {
    parameters: {
      path: {
        /** Tier name */
        policyName: parameters["policyName"];
        /** List API or Application or Resource type policies. */
        policyLevel: parameters["policyLevel"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Tier returned
       */
      200: {
        headers: {};
        schema: definitions["ThrottlingPolicy"];
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses["NotFound"];
      406: responses["NotAcceptable"];
    };
  };
  /** This operation provides you a list of available all global level mediation policies. */
  getAllGlobalMediationPolicies: {
    parameters: {
      query: {
        /** Maximum size of resource array to return. */
        limit?: parameters["limit"];
        /** Starting point within the complete list of items qualified. */
        offset?: parameters["offset"];
        /** -Not supported yet- */
        query?: string;
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * List of mediation policies is returned.
       */
      200: {
        headers: {};
        schema: definitions["MediationList"];
      };
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      406: responses["NotAcceptable"];
    };
  };
  /** This operation can be used to download a particular global mediation policy. */
  getGlobalMediationPolicyContent: {
    parameters: {
      path: {
        /** Mediation policy Id */
        mediationPolicyId: parameters["mediationPolicyId"];
      };
      header: {
        /**
         * Validator for conditional requests; based on the ETag of the formerly retrieved
         * variant of the resource.
         */
        "If-None-Match"?: parameters["If-None-Match"];
      };
    };
    responses: {
      /**
       * OK.
       * Mediation policy returned.
       */
      200: unknown;
      /**
       * Not Modified.
       * Empty body because the client has already the latest version of the requested resource (Will be supported in future).
       */
      304: never;
      404: responses["NotFound"];
    };
  };
  /** Using this operation, user can check a given role name exists or not. */
  validateSystemRole: {
    parameters: {
      path: {
        /**
         * The Base 64 URL encoded role name with domain. If the given role is in secondary user-store, role ID should be
         * derived as Base64URLEncode({user-store-name}/{role-name}). If the given role is in PRIMARY user-store, role ID
         * can be derived as Base64URLEncode(role-name)
         */
        roleId: parameters["roleId"];
      };
    };
    responses: {
      /** OK. Requested role name exists. */
      200: unknown;
      404: responses["NotFound"];
    };
  };
  /** Using this operation, logged-in user can check whether he has given role. */
  validateUserRole: {
    parameters: {
      path: {
        /**
         * The Base 64 URL encoded role name with domain. If the given role is in secondary user-store, role ID should be
         * derived as Base64URLEncode({user-store-name}/{role-name}). If the given role is in PRIMARY user-store, role ID
         * can be derived as Base64URLEncode(role-name)
         */
        roleId: parameters["roleId"];
      };
    };
    responses: {
      /** OK. Requested user has the role. */
      200: unknown;
      404: responses["NotFound"];
    };
  };
  /** Retrieve external stores list configured to publish an API */
  getAllExternalStores: {
    responses: {
      /**
       * OK.
       * External Stores list returned
       */
      200: {
        schema: definitions["ExternalStore"];
      };
      500: responses["InternalServerError"];
    };
  };
  /** This operation is to get tenants by state */
  getTenantsByState: {
    parameters: {
      query: {
        /**
         * The state represents the current state of the tenant
         *
         * Supported states are [active, inactive]
         */
        state?: "active" | "inactive";
        /** Maximum size of resource array to return. */
        limit?: parameters["limit"];
        /** Starting point within the complete list of items qualified. */
        offset?: parameters["offset"];
      };
    };
    responses: {
      /**
       * OK.
       * Tenant names returned.
       */
      200: {
        headers: {};
        schema: definitions["TenantList"];
      };
      404: responses["NotFound"];
      406: responses["NotAcceptable"];
    };
  };
  /** This operation is used to get the list of supportd alert types for the 'publisher' agent. */
  getPublisherAlertTypes: {
    responses: {
      /**
       * OK.
       * The list of publisher alert types are returned.
       */
      200: {
        headers: {};
        schema: definitions["AlertTypesList"];
      };
      500: responses["InternalServerError"];
    };
  };
  /** This operation is used to get the list of subscribed alert types by the user. */
  getSubscribedAlertTypes: {
    responses: {
      /**
       * OK.
       * The list of subscribed alert types are returned.
       */
      200: {
        headers: {};
        schema: definitions["AlertsInfo"];
      };
      500: responses["InternalServerError"];
    };
  };
  /** This operation is used to get the list of subscribed alert types by the user. */
  subscribeToAlerts: {
    parameters: {
      body: {
        /** The alerts list and the email list to subscribe. */
        body: definitions["AlertsInfo"];
      };
    };
    responses: {
      /**
       * OK.
       * Successful response with the newly subscribed alerts.
       */
      201: {
        headers: {};
        schema: definitions["AlertsInfoResponse"];
      };
      400: responses["BadRequest"];
      500: responses["InternalServerError"];
    };
  };
  /** This operation is used to unsubscribe the respective user from all the alert types. */
  unsubscribeAllAlerts: {
    responses: {
      /**
       * OK.
       * The user is unsubscribed from the alerts successfully.
       */
      200: unknown;
      500: responses["InternalServerError"];
    };
  };
  /** This operation is used to get all configurations of the AbnormalRequestsPerMin alert type. */
  getAllAlertConfigs: {
    parameters: {
      path: {
        /** The alert type. */
        alertType: parameters["alertType"];
      };
    };
    responses: {
      /**
       * OK.
       * The store alert configuration.
       */
      200: {
        headers: {};
        schema: definitions["AlertConfigList"];
      };
      500: responses["InternalServerError"];
    };
  };
  /** This operation is used to add configuration for the AbnormalRequestsPerMin alert type. */
  addAlertConfig: {
    parameters: {
      path: {
        /** The alert type. */
        alertType: parameters["alertType"];
        /** The alert configuration id. */
        configurationId: parameters["configurationId"];
      };
      body: {
        /** Configuration for AbnormalRequestCount alert type */
        body: definitions["AlertConfigInfo"];
      };
    };
    responses: {
      /**
       * Created.
       * Successful response with newly created object as entity.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {};
        schema: definitions["AlertConfig"];
      };
      400: responses["BadRequest"];
      500: responses["InternalServerError"];
    };
  };
  /** This operation is used to delete configuration from the AbnormalRequestsPerMin alert type. */
  deleteAlertConfig: {
    parameters: {
      path: {
        /** The alert type. */
        alertType: parameters["alertType"];
        /** The alert configuration id. */
        configurationId: parameters["configurationId"];
      };
    };
    responses: {
      /**
       * OK.
       * The alert config is deleted successfully.
       */
      200: unknown;
      400: responses["BadRequest"];
      404: responses["NotFound"];
      500: responses["InternalServerError"];
    };
  };
  /** Using this operation, user can check whether a given tenant exists or not. */
  getTenantExistence: {
    parameters: {
      path: {
        /** The domain of a specific tenant */
        tenantDomain: parameters["tenantDomain"];
      };
    };
    responses: {
      /** OK. Requested tenant exists. */
      200: unknown;
      404: responses["NotFound"];
    };
  };
  /** This operation can be used to get all the available Shared Scopes. */
  getSharedScopes: {
    parameters: {
      query: {
        /** Maximum size of resource array to return. */
        limit?: parameters["limit"];
        /** Starting point within the complete list of items qualified. */
        offset?: parameters["offset"];
      };
    };
    responses: {
      /**
       * OK.
       * Shared Scope list is returned.
       */
      200: {
        headers: {};
        schema: definitions["ScopeList"];
      };
      500: responses["InternalServerError"];
    };
  };
  /** This operation can be used to add a new Shared Scope. */
  addSharedScope: {
    parameters: {
      body: {
        /** Scope object that needs to be added */
        body: definitions["Scope"];
      };
    };
    responses: {
      /**
       * Created.
       * Successful response with the newly created Scope object as an entity in the body.
       */
      201: {
        headers: {};
        schema: definitions["Scope"];
      };
      400: responses["BadRequest"];
      415: responses["UnsupportedMediaType"];
    };
  };
  /** This operation can be used to retrieve details of a Shared Scope by a given scope Id. */
  getSharedScope: {
    parameters: {
      path: {
        /** Scope Id consisting the UUID of the shared scope */
        scopeId: parameters["scopeId"];
      };
    };
    responses: {
      /**
       * OK.
       * Requested Shared Scope is returned.
       */
      200: {
        headers: {};
        schema: definitions["Scope"];
      };
      404: responses["NotFound"];
    };
  };
  /** This operation can be used to update a Shared Scope by a given scope Id. */
  updateSharedScope: {
    parameters: {
      path: {
        /** Scope Id consisting the UUID of the shared scope */
        scopeId: parameters["scopeId"];
      };
      body: {
        /** Scope object that needs to be updated */
        body: definitions["Scope"];
      };
    };
    responses: {
      /**
       * OK.
       * Successful response with updated Scope object
       */
      200: {
        headers: {};
        schema: definitions["Scope"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
    };
  };
  /** This operation can be used to delete a Shared Scope proving the Id of the scope. */
  deleteSharedScope: {
    parameters: {
      path: {
        /** Scope Id consisting the UUID of the shared scope */
        scopeId: parameters["scopeId"];
      };
    };
    responses: {
      /**
       * OK.
       * Resource successfully deleted.
       */
      200: unknown;
      404: responses["NotFound"];
    };
  };
  /** Using this operation, user can check a given scope name exists or not. */
  validateScope: {
    parameters: {
      path: {
        /** Scope name */
        scopeId: parameters["scopeName"];
      };
    };
    responses: {
      /** OK. Requested scope name exists. */
      200: unknown;
      404: responses["NotFound"];
    };
  };
  /** This operation can be used to retrieve usages of a Shared Scope by a given scope Id. */
  getSharedScopeUsages: {
    parameters: {
      path: {
        /** Scope Id consisting the UUID of the shared scope */
        scopeId: parameters["scopeId"];
      };
    };
    responses: {
      /**
       * OK.
       * Usages of the shared scope is returned.
       */
      200: {
        headers: {};
        schema: definitions["SharedScopeUsage"];
      };
      404: responses["NotFound"];
    };
  };
  /**
   * This operation can be used to retrieve cloud clusters information defines in tenant-conf.json file.
   *
   * With that you can deploy an API to selected cloud environments.
   */
  deploymentsGet: {
    responses: {
      /** OK. Successful response with the list of deployment environments information in the body. */
      200: {
        headers: {};
        schema: definitions["DeploymentList"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
      500: responses["InternalServerError"];
    };
  };
  /**
   * This operation can be used to retrieve the status of deployments in cloud clusters.
   *
   * With that you can get the status of the deployed APIs in cloud environments.
   */
  deploymentsGetStatus: {
    parameters: {
      path: {
        /** **API ID** consisting of the **UUID** of the API. */
        apiId: parameters["apiId"];
      };
    };
    responses: {
      /** OK. Successful response with the list of deployment environments information in the body. */
      200: {
        headers: {};
        schema: definitions["DeploymentStatusList"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
      500: responses["InternalServerError"];
    };
  };
}

export interface external {}
